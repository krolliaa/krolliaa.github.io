<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>SpringCloud Study | Krolliaa</title><meta name="keywords" content="框架,SpringCloud"><meta name="author" content="Krolliaa"><meta name="copyright" content="Krolliaa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpringCloud1. 微服务微服务技术不等于SpringCloud它们两个属于包含关系。下列包括记录员【注册中心】 + 管理员【配置中心】 + 安全员【服务网关】 + 守护员【分布式缓存】 + 侦察员【分布式搜索】 + 存储员【消息队列】 + 监察员A【分布式日志服务】 + 监察员B【分系统监控链路追踪 】 + 一群服务员【Jenkins + Docker + K8S + RANCHER】">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringCloud Study">
<meta property="og:url" content="http://example.com/2022/08/15/SpringCloud/index.html">
<meta property="og:site_name" content="Krolliaa">
<meta property="og:description" content="SpringCloud1. 微服务微服务技术不等于SpringCloud它们两个属于包含关系。下列包括记录员【注册中心】 + 管理员【配置中心】 + 安全员【服务网关】 + 守护员【分布式缓存】 + 侦察员【分布式搜索】 + 存储员【消息队列】 + 监察员A【分布式日志服务】 + 监察员B【分系统监控链路追踪 】 + 一群服务员【Jenkins + Docker + K8S + RANCHER】">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/index_img/1.jpg">
<meta property="article:published_time" content="2022-08-15T03:31:17.665Z">
<meta property="article:modified_time" content="2022-08-15T03:32:20.842Z">
<meta property="article:author" content="Krolliaa">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="SpringCloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/index_img/1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/15/SpringCloud/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringCloud Study',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-15 11:32:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/header.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/plan"><i class="fa-fw fas fa-link"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index_img/1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Krolliaa</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/plan"><i class="fa-fw fas fa-link"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringCloud Study</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-15T03:31:17.665Z" title="发表于 2022-08-15 11:31:17">2022-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-15T03:32:20.842Z" title="更新于 2022-08-15 11:32:20">2022-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Framework/">Framework</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a><code>SpringCloud</code></h1><h2 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1. 微服务"></a>1. 微服务</h2><p>微服务技术不等于<code>SpringCloud</code>它们两个属于包含关系。下列包括记录员【注册中心】 + 管理员【配置中心】 + 安全员【服务网关】 + 守护员【分布式缓存】 + 侦察员【分布式搜索】 + 存储员【消息队列】 + 监察员<code>A</code>【分布式日志服务】 + 监察员<code>B</code>【分系统监控链路追踪 】 + 一群服务员【<code>Jenkins</code> + <code>Docker</code> + <code>K8S</code> + <code>RANCHER</code>】</p>
<ul>
<li><p>微服务首先要做的第一件事情就是拆分，根据功能从单体中拆分一个一个模块，从而形成一个<font color="pink">【服务集群】</font></p>
</li>
<li><p>拆分出来的模块可能有好几千个，想光靠人去处理效率非常低，所以就有了<font color="pink">【注册中心】</font>，它相当于一个记录员，记录了每一个模块的<code>IP</code>还有端口以及各个模块都有什么功能，当有一个模块想调用另外一个模块的功能的时候，它不需要自己去记录对方模块的<code>IP</code>、端口等信息只需要去找注册中心这个记录员就好了【拉取或注册服务信息】。</p>
</li>
<li><p>每一个服务或者你叫它模块也可以都有一个相对应的配置文件，这么多的模块成千上万个，难道要修改配置的时候还要从<code>IDEA</code>一个个去翻一个个去找吗？当然不是，这时候就需要有一个<font color="pink">【配置中心】</font>，它相当于一个管理员，管理配置的，如果某天你想更改某个服务的配置只需要到配置中心去改就好了，不用一个个去找这么麻烦，这个管理员它会去通知相关的服务更新配置且热更新【修改即改不用重启服务】</p>
</li>
<li><p>有了各个服务再加上有了记录员注册中心以及管理员配置中心，此时用户其实就可以访问服务集群里的服务了，但是用户可不可以访问以及怎么知道该访问的服务在哪里呢？总不能随便让人进来访问我的服务，万一这人是来捣乱或者图谋不轨的怎么办？所以此时就需要一个安全员，也就是<font color="pink">【服务网关】</font>，一方面对用户身份做校验，并且可以把用户的请求路由到各个服务模块，并且可以在此过程中做一些负载均衡，服务模块处理然后把数据返回给用户</p>
</li>
<li><p>到现在看似好像都没什么问题了？但是有一个问题，就是万一用户的数量太多太多了都去访问数据库，万一数据库崩了怎么办？所以呢为了保险起见，我们需要一个保护数据库任务的守护员，这个守护员就是<font color="pink">【分布式缓存】</font>，用户来了先去访问这个分布式缓存，未命中再去访问数据库，分担了数据库不小的压力</p>
</li>
<li><p>现在好了吧，我有了服务集群、记录员注册中心、管理员配置中心、还有安全员服务网关以及守护员分布式缓存保护数据库，你没话讲了吧，不，我还有话讲，万一你这个要搜索要获取非常非常海量数据的满足特定条件的一两条数据，你该怎么办？啊这…所以就要还要有侦察员<font color="pink">【分布式搜索】</font>，记录员 + 管理员 + 安全员 + 守护员 + 侦察员，各司其职形成了微服务架构</p>
</li>
<li><p>到这就真的完毕了吗？假设现在某个用户访问了<code>A</code>模块，然后又访问了<code>B</code>模块，一直一直这样访问到<code>Z</code>模块，那么这条访问链路不用想那是相当相当的长，这边用户等的就可捉急了，咋办？此时就要引入转储员<font color="pink">【消息队列】</font>，模块<code>A</code>只需要去通知各个模块完成他们的功能即可，然后<code>A</code>模块直接就完成了它的任务返回给了用户，这就大大缩短了响应时间，可以处理秒杀高并发</p>
</li>
<li><p>再来思考一个问题？如此庞大的一个服务架构，万一某一处出了点问题，好排查吗？当然不好排查。所以就需要有一个实时监视这整个服务的监察员<code>A</code><font color="pink">【分布式日志服务】</font>，它可以去统一存储统计分析整个服务的日志还有我们的监察员<code>B</code><font color="pink">【系统监控链路追踪】</font>，它可以去实时监视每一个服务节点的运行状态，<code>CPU</code>占用信息等</p>
</li>
<li><p>最后这么庞大的一个微服务集群，人工部署是不是非常的麻烦比较效率低下呢？这时候就要请一群服务员了，让他们去帮我们自动化部署整个项目，持续集成<font color="pink">【<code>Jenkins</code>、<code>Docker</code>、<code>K8S</code>、<code>RANCHAER</code>】</font></p>
<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/67a95be4c2724b8bae997f029147f87f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
</li>
</ul>
<h2 id="2-如何学习"><a href="#2-如何学习" class="headerlink" title="2. 如何学习"></a>2. 如何学习</h2><p>微服务篇可以看到整个微服务也忒复杂了，把这个学好出去岂不是横着走？那么这么复杂的微服务该如何学习呢？</p>
<p>重要的就是练习练习再练习，达到熟练的程度</p>
<p>分九步走【实用篇<code>1-4</code> + 高级篇<code>5-9</code>】：</p>
<ol>
<li>微服务治理：<code>Eureka</code>、<code>Nacos</code>、<code>OpenFeign</code>、网关<code>GateWay</code></li>
<li><code>Docker</code>：<code>Docker原理</code>、<code>Docker使用</code>、<code>Dockerfile</code>、<code>DockerCompose</code></li>
<li>异步通信：同步和异步、<code>MQ</code>技术选型、<code>SpringAMQP</code>、消费者限流</li>
<li>分布式搜索：<code>DSL</code>语法、<code>HighLevelClient</code>、拼音搜索、自动补全、竞价排名、地理搜索、聚合统计、分片集群</li>
<li>微服务保护：流量控制、系统保护、熔断降级、服务授权</li>
<li>分布式事务：<code>XA</code>模式、<code>TCC</code>模式、<code>AT</code>模式、<code>Saga</code>模式</li>
<li>分布式缓存：数据持久化、<code>Redis</code>主从集群、哨兵机制、<code>Redis</code>分片集群</li>
<li>多级缓存：多级缓存分层、<code>Nginx</code>缓存、<code>Redis</code>缓存、<code>Canal</code>数据同步</li>
<li>可靠消息服务：消息三方确认、惰性队列、延迟队列、镜像集群、仲裁队列</li>
</ol>
<h2 id="3-微服务架构的演变"><a href="#3-微服务架构的演变" class="headerlink" title="3. 微服务架构的演变"></a>3. 微服务架构的演变</h2><blockquote>
<ul>
<li>单体架构：将业务所有的功能集中在一个项目中开发，打包部署即可</li>
<li>优点：架构简单 + 部署成本低</li>
<li>缺点：耦合度高 + 一旦项目很大打包时间也将非常长</li>
</ul>
<hr>

<ul>
<li>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务<ul>
<li>优点：降低服务耦合 + 有利于服务升级扩展</li>
<li>问题：分布式需要考虑许多问题，比如访问量大的时候并且放置服务器故障你得做个集群然后你得做远程过程调用<code>RPC</code>，服务拆分粒度如何？服务集群地址如何维护？服务之间如何实现远程调用<code>RPC</code>？服务健康状态如何感知？</li>
</ul>
</li>
</ul>
<hr>

<ul>
<li>如何解决分布式上面所阐述的问题，当前最好的解决方案就是 —&gt; 微服务【还是分布式架构】<ul>
<li>微服务是一种经过良好架构设计的分布式架构方案，微服务机构特征：<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责避免重复业务开发</li>
<li>面向服务：微服务对外暴露业务接口</li>
<li>自治：符合敏捷开发的思路，团队独立、技术独立、数据独立【有自己独立的数据库】、部署独立【用户可以根据自己的需求去访问】</li>
<li>隔离性强：服务调用做好隔离、容错、降级、避免出现级联问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>总结：</p>
<ol>
<li>单体架构特点：简单方便、高度耦合、扩展性差，适合小型项目，比如：学生管理系统</li>
<li>分布式架构特点：松耦合、扩展性好但是架构复杂、难度大，适合大型项目，比如：京东、淘宝</li>
<li>微服务：一种良好的分布式架构方案<ul>
<li>优点：拆分粒度更小、服务更独立、耦合度更低</li>
<li>缺点：架构非常复杂、运维、监控、部署难度提高</li>
</ul>
</li>
</ol>
<p>在国内常用微服务方案落地实现的具体技术框架有：<code>SpringCloud</code> + <code>Dubbo</code> + <code>SpringCloud Alibaba</code></p>
<h2 id="4-微服务技术对比和企业常用"><a href="#4-微服务技术对比和企业常用" class="headerlink" title="4. 微服务技术对比和企业常用"></a>4. 微服务技术对比和企业常用</h2><table>
<thead>
<tr>
<th></th>
<th align="center"><code>Dubbo</code></th>
<th align="center"><code>SpringCloud</code>【整合，只支持<code>Feign</code>方式】</th>
<th align="center"><code>SpringCloud Alibaba</code>【越来越火，重点，支持<code>Feign</code>又支持<code>Dubbo</code>】</th>
</tr>
</thead>
<tbody><tr>
<td>注册中心</td>
<td align="center"><code>Zookeeper</code>、<code>Redis</code>【别人的】</td>
<td align="center">Eureka、Consul</td>
<td align="center"><code>Nacos</code>】、<code>Eureka</code></td>
</tr>
<tr>
<td>远程过程调用</td>
<td align="center"><code>Dubbo</code>协议【核心】</td>
<td align="center">Feign（<code>http</code>协议）</td>
<td align="center"><code>Dubbo</code>、<code>Feign</code></td>
</tr>
<tr>
<td>配置中心</td>
<td align="center">无</td>
<td align="center"><code>SpringCloudConfig</code></td>
<td align="center"><code>SpringCloudConfig</code>、<code>Nacos</code></td>
</tr>
<tr>
<td>服务网关</td>
<td align="center">无</td>
<td align="center"><code>SpringCloudGateway</code>、<code>Zuul</code></td>
<td align="center"><code>SpringCloudGateway</code>、<code>Zuul</code></td>
</tr>
<tr>
<td>服务监控和保护</td>
<td align="center"><code>dubbo-admin</code>、功能弱</td>
<td align="center"><code>Hystrix</code></td>
<td align="center"><code>Sentinel</code></td>
</tr>
</tbody></table>
<ul>
<li><p>企业常用选型第一种：<code>SpringCloud + Feign</code>，使用<code>SpringCloud</code>技术栈，服务接口采用<code>Restful</code>风格，服务远程过程调用采用<code>Feign</code>方式</p>
</li>
<li><p>企业常用选型第二种：<code>SpringCloudAlibaba + Feign</code>，使用<code>SpringCloudAlibaba</code>技术栈，服务接口采用<code>Restful</code>风格，服务调用采用<code>Feign</code>方式</p>
</li>
<li><p>企业常用选型第三种：<code>SpringCloudAlibaba + Dubbo</code>，使用<code>SpringCloudAlibaba</code>技术栈，服务接口采用<code>Dubbo</code>协议标准，服务远程过程调用采用<code>Dubbo</code>方式</p>
</li>
<li><p>企业常用选型第四种：<code>Dubbo</code>原始模式，基于<code>Dubbo</code>老旧技术体系，服务接口采用<code>Dubbo</code>协议标准，服务远程过程调用采用<code>Dubbo</code>方式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/7bb5d2a2acee45daae5fdc7165cacafc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
</li>
</ul>
<h2 id="5-初步认识SpringCloud"><a href="#5-初步认识SpringCloud" class="headerlink" title="5. 初步认识SpringCloud"></a>5. 初步认识<code>SpringCloud</code></h2><p><code>SpringCloud</code>是目前国内甚至可以说是全球使用最广泛的微服务架构，集成了各种微服务软件功能组件，并基于<code>SpringBoot</code>实现了这些组件的自动装配，开箱即用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/fade331c62d2415391bf3d8347260c12.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><code>SpringCloud</code>为什么能够推广开来就是因为基于<code>SpringBoot</code>实现了许多组件的自动装配，这样拿过来就可以直接使用了，而不用去学习原生的方法，这就是为什么<code>SpringCloud</code>可以推广开来，本质上靠的是<code>SpringBoot</code>【人家是由很扎实的基础的】</p>
<p><code>SpringCloud</code>和<code>SpringBoot</code>存在兼容性 问题，最佳适应版本需要前往<code>SpringCloud</code>的官网查看</p>
<p>本次学习使用的<code>SpringCloud</code>版本为：<code>Hoxton.SR10</code>，对应<code>SpringBoot 2.3.x</code></p>
<h2 id="6-服务拆分和远程调用"><a href="#6-服务拆分和远程调用" class="headerlink" title="6. 服务拆分和远程调用"></a>6. 服务拆分和远程调用</h2><p>注意事项：</p>
<ol>
<li>不同的微服务，不要重复开发相同业务，如果出现了那说明做的有问题</li>
<li>微服务数据独立，不要访问其它服务的数据库，这就从根源上杜绝了耦合性的业务【分库分表】</li>
<li>微服务可以将自己的业务暴露为接口，供其它服务使用</li>
</ol>
<p><code>Demo</code>：</p>
<p>项目结构：<code>cloud-demo</code> —&gt; <code>order-service</code>订单服务 + <code>user-service</code>用户服务</p>
<p>数据独立：<code>cloud-user.sql</code>[用户] + <code>cloud-order.sql</code>[订单]</p>
<ol>
<li>创建订单服务数据库：<code>cloud_order.database</code>[直接导入]</li>
<li>创建用户服务数据库：<code>cloud_user.database</code>[直接导入]</li>
<li>直接导入资源文件<code>cloud-demo</code></li>
</ol>
<p>如何实现远程服务调用？之前在前端我们可以通过<code>Ajax</code>查询出数据，那么在<code>order</code>这一段能不能通过<code>http</code>请求查询出<code>user</code>呢？显然该方案是可行的。</p>
<p>问题就成为了如何在<code>order</code>这一段发送<code>http</code>请求呢？<code>Spring</code>提供了一个工具可以用来发送<code>http</code>请求 —&gt; <code>RestTemplate</code> —&gt; 通过<code>RestTemplate</code>远程调用<code>http://localhost:8081/user/&#123;userId&#125;</code>获取到<code>User</code>将其赋予给<code>order-service</code>模块的<code>pojo.User</code>。【该项任务是业务处理的一部分所以放到<code>service</code>层中去写代码】</p>
<p>上述代码已放置<code>github</code>仓库：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ee944eb5299c44b58cb304e97d74053d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="7-服务提供者和服务消费者"><a href="#7-服务提供者和服务消费者" class="headerlink" title="7. 服务提供者和服务消费者"></a>7. 服务提供者和服务消费者</h2><ul>
<li>服务提供者：一次业务中，被其它微服务调用的服务（暴露接口给其它微服务调用）</li>
<li>服务消费者：一次业务中，调用其它微服务的服务（调用其它微服务提供的接口）</li>
<li>一个服务既可以是提供者也可以是消费者</li>
</ul>
<h2 id="8-Eureka注册中心"><a href="#8-Eureka注册中心" class="headerlink" title="8. Eureka注册中心"></a>8. <code>Eureka</code>注册中心</h2><p>之前我们的<code>order</code>服务去调用<code>user</code>服务的时候采用的是硬编码的方式即直接写代码的方式：试想这种会造成什么问题？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a5909ac5b9f3400a9af7e04f64eabb9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<ol>
<li><p>项目创建过程中有许多环境，生产环境测试环境开发环境，这些个<code>URL</code>地址肯定不一样，难道每换一个环境就要更改一次代码吗？这显然非常的麻烦</p>
</li>
<li><p>现在这里只有一个<code>user-service</code>，端口是<code>8081</code>，试想如果<code>user-service</code>做了集群，除了<code>8081</code>还有<code>8082 8083</code>等等端口，那难道每次调用的时候都去更改代码吗？如果更改了代码，做集群还有意义吗？显然是没有的。而且万一挑选的那一台服务是不健康的挂了的呢？你如何确保可以准确的调用该接口呢？</p>
</li>
</ol>
<p>那要怎么解决呢？<code>Eureka</code>注册中心解决这种硬编码带来的大问题：</p>
<ol>
<li><code>Eureka</code>注册中心将自身称为**<font color="red"><code>eureka-server</code>注册中心服务端</font><strong>，将其余的像<code>order-service</code>和<code>user-service</code>这些统称为是</strong><font color="red"><code>eureka-client</code>注册中心客户端</font>**。</li>
<li>秉承一个服务既可能是服务调用者也可能是服务提供者的理念，所有的服务只要存在都会将自己的注册服务信息注册到<code>eureka-server</code>注册中心服务端中，该动作叫做**<font color="red">注册服务信息</font>**</li>
<li>那如果一个服务挂了怎么办？不用担心，因为<code>eureka-server</code>有**<font color="red">心跳检测</font><strong>，</strong>每隔<code>30s</code>，<code>eureka-client</code>注册中心客户端需要发送1次心跳**，注册中心服务端会更新注册服务列表，对不正常的服务信息进行删除，服务调用者可以拉取到最新的服务信息</li>
<li>当某个服务调用者需要某个服务的时候就会从<code>eureka-server</code>注册中心服务端中调用服务，比如这里做了集群有三个<code>user-service</code>，都会拉取过来，该动作叫做**<font color="red">拉取服务提供者的信息</font>**</li>
<li>拉取过来具体选哪个服务调用需要使用到**<font color="red">负载均衡技术</font>**</li>
<li>确定了哪个服务之后<code>order-service</code>就会通过**<font color="red">远程调用</font>**调用某个端口的服务提供者<code>user-service</code></li>
</ol>
<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/90213662777c4cc2b6b6fa27816f4f72.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>问题描述及解答：</p>
<ol>
<li><strong><font color="deepskyblue">消费者该如何获取服务提供者的具体信息？</font></strong><ul>
<li>服务【无论是服务提供者还是服务调用者<code>eureka-client</code>】启动时都会向注册中心服务端<code>eureka-server</code>注册服务信息，注册中心服务端会保存这些信息</li>
<li>服务调用者即消费者会从注册中心服务端<code>eureka-server</code>拉取服务信息</li>
</ul>
</li>
<li><strong><font color="deepskyblue">如果有多个服务提供者，消费者该如何选择？</font></strong><ul>
<li>消费者即服务调用者会通过负载均衡技术，从从注册中心服务端拉取过来的服务选择一个</li>
</ul>
</li>
<li><strong><font color="deepskyblue">消费者如何感知提供者健康状态？</font></strong><ul>
<li>每隔<code>30s</code>服务提供者就会向<code>eureka-server</code>注册中心服务端发送心跳请求，报告当前健康状态</li>
<li>对于不正常的服务信息，注册中心服务端<code>eureka-server</code>会将其从服务信息列表中删除</li>
<li>服务调用者即消费者可以从注册中心服务端中拉取到最新的服务信息</li>
</ul>
</li>
</ol>
<p>【注：<code>eureka</code>也是一个微服务，需要注册<code>eureka</code>自己本身】</p>
<h3 id="8-1-搭建eureka-server"><a href="#8-1-搭建eureka-server" class="headerlink" title="8.1 搭建eureka-server"></a>8.1 搭建<code>eureka-server</code></h3><ol>
<li><p>创建项目，配置<code>spring-cloud-starter-netflix-eureka-server</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--版本可以不写，因为在父pom已经编写好--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写启动类，添加<code>@EnableEurekaServer</code>注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwm.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加<code>application.properties</code>文件，编写该配置文件</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口[任意]</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">10086</span></span><br><span class="line"><span class="comment"># 服务名称 - 微服务名称[为了做服务注册]</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">eureka-server</span></span><br><span class="line"><span class="comment"># 配置eureka地址信息[eureka 也是一个微服务，把自己也注册在eureka身上][为了做服务注册]</span></span><br><span class="line"><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>点击<code>IDEA</code>端口可以直接跳转到<code>eureka</code>管理页面，访问：<code>http://localhost:10086</code>[没有后缀]</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/fb33d846a96e4292a1855a60b8785267.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
</li>
</ol>
<h3 id="8-2-搭建eureka-client"><a href="#8-2-搭建eureka-client" class="headerlink" title="8.2 搭建eureka-client"></a>8.2 搭建<code>eureka-client</code></h3><p>将<code>user-service</code>和<code>order-service</code>服务注册到<code>EurakaServer</code>：</p>
<ol>
<li><p>在<code>user-service</code>的<code>pom.xml</code>中引入依赖：<code>spring-cloud-starter-netflix-eureka-client</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>application.properties</code>配置注册服务：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">user-service</span></span><br><span class="line"><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>按照上述步骤可以注册<code>order-service</code>，这里不再赘述</li>
</ul>
<p><code>IDEA</code>可以模拟启动多个服务：<code>ctrl+D</code>或者右键服务选择<code>	Copy Configuration</code>然后配置一下<code>VM options: -Dserver.port=8082</code> —&gt; <code>apply</code> —&gt; <code>ok</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/57c02b3dbf9d43fba47d870f62418b4f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>完成后<code>eureka-service</code>显示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/87a5506f10994a8f8274f1740c500cc0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>到这里就完成了将服务注册到<code>eureka</code></p>
<h3 id="8-3-Eureka-服务发现"><a href="#8-3-Eureka-服务发现" class="headerlink" title="8.3. Eureka 服务发现"></a>8.3. <code>Eureka</code> 服务发现</h3><ol>
<li><p>修改源代码，将其改为<code>spring.application.name</code>的名称，这个服务已经在注册中心<code>eureka</code>中注册好了，所以直接调用消费即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a5909ac5b9f3400a9af7e04f64eabb9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Order&gt; <span class="title function_">findAllOrders</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Order&gt; orderList = orderMapper.selectAllOrders();</span><br><span class="line">    <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">        <span class="comment">//String url = &quot;http://localhost:8081/getUserById?id=&quot; + order.getUserId();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://user-service/getUserById?id=&quot;</span> + order.getUserId();</span><br><span class="line">        order.setUser(restTemplate.getForObject(url, User.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orderList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给<code>RestTemplate</code>上加入<code>@LoadBanlanced</code>引入负载均衡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>重启服务，成功实现<code>order-service</code>通过注册中心拉取<code>user-service</code>注册到<code>eureka</code>的服务信息，并引入负载均衡，通过在<code>application.properties</code>中配置<code>mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code>可以发现<code>UserApplication:8081</code>和<code>UserApplication:8082</code>都被调用了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/538bea1b57aa4349b884e8ed4234278d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h3 id="8-4-LoadBalanced注解原理-—-gt-Ribbon负载均衡流程"><a href="#8-4-LoadBalanced注解原理-—-gt-Ribbon负载均衡流程" class="headerlink" title="8.4. @LoadBalanced注解原理 —&gt; Ribbon负载均衡流程"></a>8.4. <code>@LoadBalanced</code>注解原理 —&gt; <code>Ribbon</code>负载均衡流程</h3><p>为什么我们在<code>RestTemplate</code>加入了<code>@LoadBalanced</code>就可以完成负载均衡？中途到底发生了什么事情？这就引出了我们要学习<code>SpringCloud</code>的第二个组件 —&gt; <code>Ribbon</code>，它是用来完成负载均衡的！</p>
<p>之前我们是将<code>order-service</code>中的<code>OrderService</code>的<code>URL</code>地址改成了：<code>http://user-service/getUserById?id=1</code>，我们直接访问这个<code>URL</code>地址，发现根本无法访问，说明这个地址被拦截了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/7348388b2832429cbd23038b2085bb9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>那是谁帮我们拦截解析了呢？答案是<code>Ribbon</code>组件</p>
<ol>
<li><code>OrderService</code>发送请求：<code>http://user-service/getUserById?id=x</code>给<code>Ribbon</code>负载均衡</li>
<li><code>Ribbon</code>从<code>eureka-server</code>中拉取<code>user-service</code></li>
<li><code>eureka-server</code>返回<code>user-service</code>服务列表给<code>Ribbon</code>负载均衡</li>
<li>最后<code>Ribbon</code>轮询获取到<code>user-service</code>服务</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/d802ea08315f4a1c88f7a518e44e1fdb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><code>@LoadBalanced</code>这个注解就表示<code>order-service</code>发送的请求会被<code>Ribbon</code>组件拦截解析，那么<code>Ribbon</code>是如何实现拉取服务，又是如何实现负载均衡的呢？其原理是什么呢？最好的方法就是深入源码一探究竟。</p>
<p>【注：该<code>eureka</code>版本为<code>2.2.7RELEASE</code>，新版本的源代码可能已经改动】</p>
<ol>
<li><p><code>order-service</code>发送<code>http://user-service/getUserById?id=x</code>请求，该请求是由<code>RestTemplate</code>发送的，因为在<code>RestTemplate</code>上加入了<code>@LoadBanlanced</code>，所以该请求会传入到<code>LoadBanlancerInterceptor.java</code>进行拦截</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/d90d44a68a9d4ba9ab175ef74c8483af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>可以看到<code>LoadBalancerInterceptor</code>实现了<code>ClientHttpRequestInterceptor</code>接口，我们点进去看看</p>
</li>
<li><p>我们可以看见<code>ClientHttpRequestInterceptor</code>接口描述第一句话就是作用：<code>对客户端HTTP请求进行拦截</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/6204f36bc1454f40896524ea30f48c9a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>也就是说这也刚好反向验证了<code>LoadBalancerInterceptor</code>拦截器对服务调用者发起的请求进行了拦截，实现了<code>ClientHttpRequestInterceptor</code>中的<code>intercept</code>方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ba9ed98b77e447cb929c91cead934f26.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
</li>
<li><p>根据最上面的流程图，下一步<code>Ribbon</code>就是要获取到服务名称，然后根据服务名称从<code>eureka-server</code>中拉取服务列表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/0e5cd3e838634411b69b09989c4e704c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>获取到服务名称然后是如何进行拉取的呢？—&gt;<code>RibbonLoadBalancerClient.java</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/87f92e54360e4f83b093f3847c4bf5ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>继续进入：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/c50e08b08e174784b8b1688d76b8eecd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>可以发现通过<code>DynamicServerListLoadBalancer.java</code>以及刚刚获取到的服务名称进一步获取到了<code>LoadBalancer</code>对象，通过<code>LoadBalancer</code>可以获取到服务列表</p>
</li>
<li><p>按照流程，从拦截请求再到获取服务名称再到获取服务列表，下一步就是要做负载均衡，对服务列表进行轮询，使用的是<code>IRule</code>接口，负载均衡轮询选择实在上述<code>getServer()</code>完成的，进入到<code>getServer()</code>看看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/88f8f66e80164e68ae1264e2d817af8f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>继续进入：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/b39488337e2349ff9ead72859cc1ae70.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>负载均衡肯定有一套规则在里面，是以什么规则进行负载均衡？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8620a678238b430a8619dc25d3b42bdc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>通过查看得知这是一个<code>IRule</code>对象，但是<code>IRule</code>是一个接口，那么它就一定有实现类，通过<code>Ctrl+H</code>可以查看某个接口的实现类：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/60ae5043a6ea40f992d01b2d631c9008.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>这里边就有一个<code>RoundRobinRule</code>表示的是轮询的意思，也就是说<code>RoundRobinRule</code>实现了轮询规则，就是按照这个方式来轮询查找服务列表中的服务</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8445db49eb2f4e32a0c799d0c377b9e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
</li>
</ol>
<p>通过上述源代码的分析，我们也就知道了个大概，知道<code>Robbin</code>组件进行了如下操作：</p>
<ol>
<li>通过<code>LoadBalancerInterceptor</code>拦截请求后并且从<code>URL</code>地址中获取服务名称</li>
<li>再通过<code>RibbonLoadBalancerClient</code>以及服务名称调用第三步获取服务列表</li>
<li><code>DynamicServerListLoadBalancer</code>从<code>eureka-server</code>中拉取服务列表</li>
<li>再通过实现<code>IRule</code>接口的<code>RobbinRoundRule</code>轮询规则进行负载均衡从服务列表中选出一台服务</li>
<li>最后通过<code>RibbonLoadBalancerClient</code>替换<code>URL</code>地址，发送请求获取服务</li>
</ol>
<p>下面这张图应该在<code>order-service</code>和<code>RibbonLoadBalancerClient</code>之间再加上一个<code>LoadBalancerInterceptor</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8973eaf72e254a68b03226ef976783fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h3 id="8-5-Eureka注册中心拉取服务列表的Robbin-—-gt-负载均衡策略"><a href="#8-5-Eureka注册中心拉取服务列表的Robbin-—-gt-负载均衡策略" class="headerlink" title="8.5.Eureka注册中心拉取服务列表的Robbin —&gt;  负载均衡策略"></a>8.5.<code>Eureka</code>注册中心拉取服务列表的<code>Robbin</code> —&gt;  负载均衡策略</h3><p><code>Ribbon</code>完成负载均衡靠得是一套规则，规则由<code>Rule</code>接口来定义，<code>Rule</code>接口的每一个子接口都是一种规则：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/0804c04f7c944c2c8ef7e9f9790af037.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><strong>实现负载均衡的策略多种多样，默认是使用<code>RoundRobbinRule</code>轮询的方式选择服务器</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/65ac29316cef46d992846a9c4f5dea16.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>先看看这种轮询的方式，可以看到<code>UserApplication1</code>中查找的是<code>1 3 5</code>，那么自然<code>UserApplication2</code>中查找的是<code>2 4 6</code>，这也证明了是通过轮询的方式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f1b848a73e744a88b34cf8da33c4201d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>通过代码的方式更换负载均衡策略，注意重启服务器，这种方式是全局配置，<code>order-service</code>调用所有的服务使用的负载均衡策略就都变成了随机选择的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RandomRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新发起请求，可以看到选择服务器的变化，在<code>id</code>为<code>3 4 5 6</code>的时候选择了<code>UserApplication1</code>作为服务器，随机选择，说明负载均衡策略更改成功</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ac8c64a6fe3343779281f09417fa2f71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>有时候，我就想调用某个服务实行的是<code>A</code>负载均衡策略，调用<code>B</code>服务的时候施行的时候<code>B</code>负载均衡策略，可以做到吗？当然可以，这种实行负载均衡策略的方式需要在配置文件中配置<code>application.properties</code> —&gt; 针对某个微服务而言：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>

<h3 id="8-6-Ribbon饥饿加载"><a href="#8-6-Ribbon饥饿加载" class="headerlink" title="8.6 Ribbon饥饿加载"></a>8.6 <code>Ribbon</code>饥饿加载</h3><p><code>Ribbon</code>默认使用的是懒加载，什么是懒加载呢？就是客户端第一次访问的时候才会去创建<code>RobbinLoadBalancerClient</code>对象，所以第一访问的时间都会非常的漫长，如下图，可以看到足足达到<code>715ms</code>之久：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/0b7ae9183e4d425d9dcc93ccf876659f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>为了加快访问速度，可以改变懒加载，配置成是饥饿加载，这样只要服务在启动的时候创建<code>LoadBalancerClient</code>对象，从而降低了第一次访问时间过长的现象，配置如下：<code>ribbon.eager-load.client</code> —&gt; 项目启动时直接去拉取<code>userservice</code>的集群，多个用”,”隔开</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon.eager-load.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">ribbon.eager-load.clients</span>=<span class="string">user-service</span></span><br></pre></td></tr></table></figure>

<p>重启服务，观察加载时间，如下图可以看到在<code>order-service</code>服务启动时就加载了<code>LoadBalancerClient</code>对象：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e07b2e8ac65c436a98caa1e9253d8d9f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>客户端访问的时间，可以看到饥饿加载相比于懒加载的时间足足降低了一半还少：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8b634ff21d894df6831e2c5141907563.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="9-Nacos注册中心"><a href="#9-Nacos注册中心" class="headerlink" title="9. Nacos注册中心"></a>9. <code>Nacos</code>注册中心</h2><h3 id="9-1-Nacos注册中心安装"><a href="#9-1-Nacos注册中心安装" class="headerlink" title="9.1 Nacos注册中心安装"></a>9.1 <code>Nacos</code>注册中心安装</h3><p><code>Nacos</code>是阿里巴巴开发的一个产品，现在是<code>SpringCloud</code>的一个组件。比<code>Eureka</code>的功能更多一点，在国内<code>Nacos</code>更受欢迎，所以学习<code>Nacos</code>还是有必要的。而且<code>Nacos</code>是<code>Java</code>语言实现的。</p>
<p>有人说<code>Eureka</code>停止更新了，其实这是个错误的说法，<code>Eureka</code>有两种版本，一种是一点几的版本，一种是二点几的版本，停止的是二点几的版本，而且这个版本的<code>Eureka</code>压根就还没有出来就停止了。【<code>2022</code>年<code>2.x</code>的版本被重新放出来了】</p>
<p>安装：<code>github</code> —&gt; 下载<code>release</code> —&gt; 解压 —&gt; 默认端口是<code>8848</code>  —&gt; 可以在配置文件中自定义端口 —&gt; 启动：<code>startup.cmd -m standalone[单机模式，-m 是 mode 的意思]</code> —&gt; 登录：<code>http://192.168.0.106:8848/nacos/index.html</code> –&gt; 账号密码均为：<code>nacos</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/d12925e16eb342d2b02b03ad4acc9355.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/d5d5f511c23142d2a3c890b8a1964384.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h3 id="9-2-Nacos实现注册与发现"><a href="#9-2-Nacos实现注册与发现" class="headerlink" title="9.2. Nacos实现注册与发现"></a>9.2. <code>Nacos</code>实现注册与发现</h3><p>【<code>Nacos</code>和<code>Eureka</code>的区别在于<code>Eureka</code>是需要你自己手动配置服务端，而<code>Nacos</code>直接就是安装包安装好了使用命令打开就是服务端，所以在<code>Nacos</code>只需要配置客户端即可】</p>
<ol>
<li><p>引入依赖 —&gt; <code>Nacos</code>是阿里巴巴提供的所以我们在父<code>pom.xml</code>引入<code>spring-cloud-alibaba</code>管理依赖，日后就不用再多加管理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉<code>eureka</code>在<code>pom</code>文件中的依赖还有配置文件中的信息</p>
</li>
<li><p>在<code>user-service</code>和<code>order-service</code>添加<code>Nacos</code>的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>user-service</code>和<code>order-service</code>中的<code>application.properties</code>配置<code>eureka</code>的配置注释掉配置<code>nacos</code>的配置 —&gt; 声明<code>Nacos</code>服务端所在的位置，监听的端口是什么？ —&gt; 这里需要将<code>eureka</code>中的信息注释掉 </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.server.addr</span>=<span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过<code>Nacos</code>的后台可以看到成功地将服务注册到了<code>Nacos</code>上：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/1b00acd58cc84fbd945cac00c06fedc1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2faaded4a346487c9657da82da90f82d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>可以看到<code>Nacos</code>的后台比<code>Eureka</code>看起来更加清爽明了，看着就很舒服。输入：<code>http://localhost:8080/getAllOrders</code>验证服务发现，可以看到是可以正常访问的，表明服务发现没问题。启动各项服务，通过访问<code>URL</code>地址可以发现跟<code>Eureka</code>的功能是完全一样的，并且界面更加友好。</p>
<h3 id="9-3-Nacos分级存储模型"><a href="#9-3-Nacos分级存储模型" class="headerlink" title="9.3 Nacos分级存储模型"></a>9.3 <code>Nacos</code>分级存储模型</h3><p>此处<code>order-service:8080 user-service:8081 user-service:8082 user-service:8083</code>我们都可以称之为一个个实例，这样的实例可能在超大型项目中有成百上千个，可能在北京广州上海深圳杭州都存放着各个实例，当我们访问某项服务的时候肯定是访问距离最近的服务才是最快的，也正因此，<code>Nacos</code>可以引入集群，从而引出<code>Nacos</code>分级存储模型：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210901091928.png"></p>
<p>这样搞的目的就是为了：服务调用的时候尽可能选择本地集群中的服务，避免跨集群调用，因为这样延迟很高，只有在本地集群中需要的服务访问不了的时候再去访问其它集群。</p>
<h3 id="9-4-Nacos配置集群"><a href="#9-4-Nacos配置集群" class="headerlink" title="9.4 Nacos配置集群"></a>9.4 <code>Nacos</code>配置集群</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.discovery.cluster-name</span>: <span class="string">Beijing</span></span><br></pre></td></tr></table></figure>

<p>直接复制多份<code>user-service</code>，将其加入到不同的集群 —&gt; <code>VM Options</code>：[三个集群 —&gt; 北京 深圳 杭州]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=<span class="number">8082</span> -Dspring.cloud.nacos.discovery.cluster-name=Beijing</span><br><span class="line">-Dserver.port=<span class="number">8083</span> -Dspring.cloud.nacos.discovery.cluster-name=Shenzhen</span><br><span class="line">-Dserver.port=<span class="number">8084</span> -Dspring.cloud.nacos.discovery.cluster-name=Shenzhen</span><br><span class="line">-Dserver.port=<span class="number">8085</span> -Dspring.cloud.nacos.discovery.cluster-name=Hangzhou</span><br><span class="line">-Dserver.port=<span class="number">8086</span> -Dspring.cloud.nacos.discovery.cluster-name=Hangzhou    </span><br></pre></td></tr></table></figure>

<p>然后将<code>order-service</code>分别拉入到<code>Beijing Shenzhen Hangzhou</code>的集群中并分别访问<code>URL</code>，观察<code>IDEA</code>中显示的信息，可以发现都是访问集群里的服务，只有在集群中的服务挂掉的时候才去跨集群访问。【记得把上次设置的<code>RandomRule</code>给注释掉否则负载均衡策略会选择随机负载均衡。】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2ec0ce78a7d4438ea4d71f71cef81d95.png"></p>
<h3 id="9-5-Nacos配置负载均衡规则"><a href="#9-5-Nacos配置负载均衡规则" class="headerlink" title="9.5 Nacos配置负载均衡规则"></a>9.5 <code>Nacos</code>配置负载均衡规则</h3><p>第一种情况：<code>order-service</code>位于<code>Beijing</code>集群，访问<code>http://localhost:8080/order/103</code>，可以看到只会访问同时<code>Beijing</code>集群的两个<code>user-service</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/635ed404649c4d609f147ecf7027ed99.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4740ff18f3874282b86f69194b36d8ff.png"></p>
<p>第二种情况：<code>order-service</code>位于<code>Shenzhen</code>集群，可以看到同样的效果，但是还访问了其它的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e6073e8d15e14d1183a7d6c2496208b6.png"></p>
<p>第三种情况：<code>order-service</code>位于<code>Hangzhou</code>集群【跟上述一致】也是还访问了其它的</p>
<p>第四种情况：<code>order-service</code>位于<code>Hangzhou</code>集群，但是集群中的<code>user-service:8085 8086</code>挂掉了，也是访问了多个。</p>
<p>为什么会这样呢？原因是<code>Nacos</code>的默认负载均衡的策略就是轮询，如果我们要配置按地区查找，我们可以看到是一个个接着顺序访问的，如果要按地区轮询我们应该修改下配置类中的<code>Bean</code>。 —&gt; <code>order-service.configuration.MyConfiguration ---&gt; NacosRule</code>并且是在集群中随机选择服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">nacosRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再去访问就是按照就近集群来访问，如果某个集群中所有服务都挂了，再去访问其它的集群服务，而且可以在日志中看到发生了跨集群访问。</p>
<p><strong>除了使用配置类还可以在配置文件中直接配置负载均衡规则：</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">spring.cloud.nacos.ribbon.NacosRule</span></span><br></pre></td></tr></table></figure>

<h3 id="9-6-Nacos配置负载均衡权重配置【服务平滑升级】"><a href="#9-6-Nacos配置负载均衡权重配置【服务平滑升级】" class="headerlink" title="9.6 Nacos配置负载均衡权重配置【服务平滑升级】"></a>9.6 <code>Nacos</code>配置负载均衡权重配置【服务平滑升级】</h3><ol>
<li><code>Nacos</code>控制台可以设置实例的权重值，值在<code>0-1</code>之间</li>
<li>同个集群内的多个实例，权重越高被访问的频率越高</li>
<li>权重设置为<code>0</code>的时候则该服务将完全不被访问</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210901092020.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210901092026.png"></p>
<p><strong>合理配置权重可以做到平滑升级，比如：先把<code>user-service:8080</code>的权重调节为<code>0</code>让用户流向<code>user-service:8081</code>，等<code>user-service:8080</code>升级完成之后再将权重从<code>0</code>更改为<code>0.1</code>让一部分用户先体验升级版本，若稳定，再将权重上调。这就可以做到平滑升级。</strong></p>
<h3 id="9-7-Nacos环境隔离namespace"><a href="#9-7-Nacos环境隔离namespace" class="headerlink" title="9.7 Nacos环境隔离namespace"></a>9.7 <code>Nacos</code>环境隔离<code>namespace</code></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210901092032.png"></p>
<p>首先想明白一个问题：为什么有了集群还要有<code>namespace</code>这样的东西呢？是不是觉得多此一举？其实不然。集群&#x2F;服务都是针对业务来进行划分的，而<code>namespace</code>命名空间是针对注入开发环境生产环境测试环境这样不同环境下诞生的产物。</p>
<p>这样我们就可以在不同环境下使用不同的集群、实例了。</p>
<p>而<code>Group</code>，就是不同环境下相关度比较高的业务，比如订单业务和支付业务是高度相关的，是概念上的划分，就可以把这两个业务都放到同一个<code>Group</code>中去，你可以使用也可以不使用。而<code>Service/Data</code>就是服务，再往下就是各个集群再往下就是实例了。</p>
<p>创建命名空间的步骤如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210901092038.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210901092050.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210901092059.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210901092114.png"></p>
<p>如何指定服务实例的命名空间？以<code>order-service</code>为例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.105</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">Beijing</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">xxxxxx</span></span><br></pre></td></tr></table></figure>

<p><strong><font color="red">每个<code>namespace</code>都有不同的唯一<code>id</code>，并且·不同<code>namespace</code>之间相互隔离即不同<code>namespace</code>的服务互不可见。</font></strong></p>
<p>访问结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-08-14T12:34:04.243+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/order/103&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-8-Nacos注册中心的细节"><a href="#9-8-Nacos注册中心的细节" class="headerlink" title="9.8 Nacos注册中心的细节"></a>9.8 <code>Nacos</code>注册中心的细节</h3><p>相同点：</p>
<ul>
<li><strong><code>Nacos</code>和<code>Eureka</code>都支持服务注册和服务拉取</strong></li>
<li><strong>都支持服务提供者心跳方式做检测</strong></li>
</ul>
<p>不同点：</p>
<ul>
<li><p><strong><code>Nacos</code>存在临时和非临时实例</strong></p>
<ul>
<li><p><strong>临时实例：</strong></p>
<p>所有的实例在没有配置的时候都是临时实例，这个可以在控制台看到临时实例是<code>true</code>。每隔一段时间，临时实例需要主动去向注册中心报告我还活着，否则心跳检测不通过，<code>Nacos</code>会直接剔除掉该项服务。</p>
<p>对于临时实例，消费者是定时主动拉取服务。</p>
</li>
<li><p><strong>非临时实例：</strong></p>
<p><code>Nacos</code>主动去询问生产者【非临时实例】，并且主动推送变更消息到消费者。告诉消费者服务更新了，让其赶紧去更新。并且当非临时实例宕机的时候，也不会从服务列表中剔除。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment">#设置为非临时实例</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>学过<code>Zookeeper</code>的应该知道<code>CAP</code>不可能三角，<code>Nacos</code>集群<strong>默认采用AP方式(可用性)<strong>，当集群中存在非临时实例时，</strong>采用<code>CP</code>模式(一致性)<strong>；而</strong><code>Eureka</code>只采用<code>AP</code>方式</strong>，不可切换。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Krolliaa</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/15/SpringCloud/">http://example.com/2022/08/15/SpringCloud/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Krolliaa</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/SpringCloud/">SpringCloud</a></div><div class="post_share"><div class="social-share" data-image="/img/index_img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/08/12/NetWorkInterview/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Computer Network Interview</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/12/SpringBootStudySimple/" title="SpringBoot Study [简单版]"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-12</div><div class="title">SpringBoot Study [简单版]</div></div></a></div><div><a href="/2022/08/12/SpringMVC/" title="SpringMVC Study"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-12</div><div class="title">SpringMVC Study</div></div></a></div><div><a href="/2022/08/11/MyBatisStudy/" title="MyBatis Study"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-11</div><div class="title">MyBatis Study</div></div></a></div><div><a href="/2022/08/12/SpringStudyStudy/" title="Spring Study"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/19.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-12</div><div class="title">Spring Study</div></div></a></div><div><a href="/2022/08/12/SpringBootStudyAll/" title="SpringBoot Study [完整版]"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-12</div><div class="title">SpringBoot Study [完整版]</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/header.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Krolliaa</div><div class="author-info__description">俱往矣，数风流人物，还看今朝！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/krolliaa"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringCloud"><span class="toc-number">1.</span> <span class="toc-text">SpringCloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">1. 微服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.2.</span> <span class="toc-text">2. 如何学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-number">1.3.</span> <span class="toc-text">3. 微服务架构的演变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94%E5%92%8C%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4. 微服务技术对比和企业常用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86SpringCloud"><span class="toc-number">1.5.</span> <span class="toc-text">5. 初步认识SpringCloud</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">6. 服务拆分和远程调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.7.</span> <span class="toc-text">7. 服务提供者和服务消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.8.</span> <span class="toc-text">8. Eureka注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%90%AD%E5%BB%BAeureka-server"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 搭建eureka-server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%90%AD%E5%BB%BAeureka-client"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 搭建eureka-client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Eureka-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3. Eureka 服务发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-LoadBalanced%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86-%E2%80%94-gt-Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4. @LoadBalanced注解原理 —&gt; Ribbon负载均衡流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%8B%89%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%E7%9A%84Robbin-%E2%80%94-gt-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5.Eureka注册中心拉取服务列表的Robbin —&gt;  负载均衡策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-Ribbon%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.8.6.</span> <span class="toc-text">8.6 Ribbon饥饿加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.9.</span> <span class="toc-text">9. Nacos注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%89%E8%A3%85"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 Nacos注册中心安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Nacos%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2. Nacos实现注册与发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-Nacos%E5%88%86%E7%BA%A7%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 Nacos分级存储模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Nacos%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4 Nacos配置集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-Nacos%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5 Nacos配置负载均衡规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-Nacos%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9D%83%E9%87%8D%E9%85%8D%E7%BD%AE%E3%80%90%E6%9C%8D%E5%8A%A1%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E3%80%91"><span class="toc-number">1.9.6.</span> <span class="toc-text">9.6 Nacos配置负载均衡权重配置【服务平滑升级】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-Nacos%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BBnamespace"><span class="toc-number">1.9.7.</span> <span class="toc-text">9.7 Nacos环境隔离namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">1.9.8.</span> <span class="toc-text">9.8 Nacos注册中心的细节</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/SpringCloud/" title="SpringCloud Study"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud Study"/></a><div class="content"><a class="title" href="/2022/08/15/SpringCloud/" title="SpringCloud Study">SpringCloud Study</a><time datetime="2022-08-15T03:31:17.665Z" title="发表于 2022-08-15 11:31:17">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/12/NetWorkInterview/" title="Computer Network Interview"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Computer Network Interview"/></a><div class="content"><a class="title" href="/2022/08/12/NetWorkInterview/" title="Computer Network Interview">Computer Network Interview</a><time datetime="2022-08-12T08:49:40.672Z" title="发表于 2022-08-12 16:49:40">2022-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/12/RedisStudy/" title="Redis Study"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis Study"/></a><div class="content"><a class="title" href="/2022/08/12/RedisStudy/" title="Redis Study">Redis Study</a><time datetime="2022-08-12T08:49:11.648Z" title="发表于 2022-08-12 16:49:11">2022-08-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/index_img/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;1984 - 2022 By Krolliaa</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div></div></body></html>