<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>RabbitMQ Study [未完结] | Krolliaa</title><meta name="keywords" content="微服务,消息队列"><meta name="author" content="Krolliaa"><meta name="copyright" content="Krolliaa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="消息中间件是什么？消息队列就是消息中间件，消息很好理解你可以理解为信息，那中间件呢？中间件是提供软件和软件之间连接的软件，以便于软件各个部件之间的沟通。在咖啡店买咖啡这个例子中，微信就是消息中间件。发送方和接收方就是被消息中间件连接的 为什么要使用消息中间件呢？同步直接调用 —&gt; 异步直接调用 —&gt; 消息中间件 先来理解下什么是同步直接调用？请看下图：   可以看到同步直接调用的整个业">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ Study [未完结]">
<meta property="og:url" content="http://example.com/2022/08/12/RabbitMQStudy/index.html">
<meta property="og:site_name" content="Krolliaa">
<meta property="og:description" content="消息中间件是什么？消息队列就是消息中间件，消息很好理解你可以理解为信息，那中间件呢？中间件是提供软件和软件之间连接的软件，以便于软件各个部件之间的沟通。在咖啡店买咖啡这个例子中，微信就是消息中间件。发送方和接收方就是被消息中间件连接的 为什么要使用消息中间件呢？同步直接调用 —&gt; 异步直接调用 —&gt; 消息中间件 先来理解下什么是同步直接调用？请看下图：   可以看到同步直接调用的整个业">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/index_img/3.jpg">
<meta property="article:published_time" content="2022-08-12T08:45:54.288Z">
<meta property="article:modified_time" content="2022-10-28T05:30:44.625Z">
<meta property="article:author" content="Krolliaa">
<meta property="article:tag" content="微服务">
<meta property="article:tag" content="消息队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/index_img/3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/12/RabbitMQStudy/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ Study [未完结]',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-28 13:30:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/header.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/plan"><i class="fa-fw fas fa-link"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index_img/3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Krolliaa</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/plan"><i class="fa-fw fas fa-link"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ Study [未完结]</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-12T08:45:54.288Z" title="发表于 2022-08-12 16:45:54">2022-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-28T05:30:44.625Z" title="更新于 2022-10-28 13:30:44">2022-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MessageQueue/">MessageQueue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>88分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="消息中间件是什么？"><a href="#消息中间件是什么？" class="headerlink" title="消息中间件是什么？"></a>消息中间件是什么？</h1><p>消息队列就是消息中间件，消息很好理解你可以理解为信息，那中间件呢？中间件是提供软件和软件之间连接的软件，以便于软件各个部件之间的沟通。<strong>在咖啡店买咖啡这个例子中，微信就是消息中间件。发送方和接收方就是被消息中间件连接的</strong></p>
<h1 id="为什么要使用消息中间件呢？"><a href="#为什么要使用消息中间件呢？" class="headerlink" title="为什么要使用消息中间件呢？"></a>为什么要使用消息中间件呢？</h1><p><strong>同步直接调用 —&gt; 异步直接调用 —&gt; 消息中间件</strong></p>
<p>先来理解下什么是同步直接调用？请看下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8c2fd1aed0bc4e4ab161b2b73f6f4ac0.png"></p>
<ul>
<li>可以看到同步直接调用的整个业务调用链非常长，这就会让用户等待的<strong>时间</strong>也变得很<strong>长</strong>。</li>
<li>而且<strong>中途</strong>只要有一个环节出现了<strong>故障</strong>就会导致<strong>整个业务瘫痪</strong>掉。这跟初中学习的串联没什么太大区别。</li>
<li>并且如果<strong>业务处于高峰期</strong>，此时某一个业务的处理能力比较<strong>拉跨</strong>的话就会导致<strong>整个系统都很拉跨</strong>。</li>
</ul>
<p>为了解决同步直接调用的这些处理时间长、局部故障导致全局故障，业务高峰期业务能力弱导致整个系统都弱的问题，就得到了<strong>异步直接调用</strong>的解决方案。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a45dfa601fb34ceeb9a0fd6f795dbf16.png"></p>
<p>可以看到异步直接调用只要用户做了操作，就立马响应转换为“处理中”这么一种效果，新建一个异步线程，然后再去处理调用各个组件。异步直接调用解决了：</p>
<ol>
<li>业务调用链虽然还是挺长，但是解决了用户等待时间长的问题</li>
<li>部分组件故障会导致整个业务瘫痪，可能业务调用链里面的组件还是会发生故障，但我用户的操作返回的结果是没问题的</li>
<li>业务高峰期没有缓冲，这个也解决了，因为用户每次操作都会从线程池中拿一个新的异步线程</li>
</ol>
<p><strong><font color="red">但是异步直接调用这样又带来了新的问题：即如果业务高峰期非常非常爆满的话，那么线程池中的异步线程终究是不够用的，就会导致内存爆满。</font></strong></p>
<p>所以就需要一个能够处理高并发的，速度非常快的这么一种东西，它每次有任务一来我就自动快速的去完成这个任务，实现高效率操作。找来找去发现消息中间件是最最合适的。所以我们再将异步直接调用调用改造成了围绕消息中间件打造的这么一种模式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a21f573f87ff4c30b28ad8fd74b81cbe.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/32279f40627945efb760a3b81dc4380b.png"></p>
<p>通过这幅图我们就可以感受到消息中间件的妙处了：</p>
<ul>
<li>整个业务调用链很短，都是交给消息中间件去做，用户等待的时间也很短。</li>
<li>某个组件故障不会导致整个业务瘫痪</li>
<li>业务高峰期还有缓冲</li>
<li>业务高峰期时不会产生大量的异步线程【之前在异步直接调用可以发现异步线程非常的长，这种非常长时间的异步线程是很容被<code>KILL</code>掉的所以一定要防止这种长时的异步线程出现，比如非常长的<code>sleep</code>】</li>
</ul>
<h1 id="消息中间件的作用"><a href="#消息中间件的作用" class="headerlink" title="消息中间件的作用"></a>消息中间件的作用</h1><ul>
<li>异步处理</li>
<li>系统解耦</li>
<li>流量削峰和流控</li>
<li>消息广播：一个服务可以发送给多个服务，类似于微信的一人群发</li>
<li>消息收集：日志收集系统</li>
<li>最终一致性：对方什么时候处理是对方的事情但是存在于消息中间的消息一定会被对方处理掉【即时间问题但是一定可以处理】</li>
</ul>
<p>总结：<strong>消息中间件就是软件和软件之间发送消息的软件</strong>，消息中间件最大的作用就是<strong>异步消息</strong>、<strong>系统解耦</strong>，此外还有<strong>流量削峰</strong>、<strong>流量控制</strong>、<strong>消息收集</strong>、<strong>消息广播</strong>等特点。</p>
<h1 id="RabbitMQ高性能的原因"><a href="#RabbitMQ高性能的原因" class="headerlink" title="RabbitMQ高性能的原因"></a><code>RabbitMQ</code>高性能的原因</h1><ul>
<li>感受下安卓和苹果的速度，<code>RabbitMQ</code>是<code>erlang</code>语言开发的，一门专门为<strong>交换机软件开发诞生的编程语言</strong>。</li>
<li>适用于分布式系统，面向并发的。</li>
<li>而且<code>erlang</code>是虚拟机解释运行的可以跨平台部署</li>
<li><code>erlang</code>的进程间上下文切换效率远高于<code>C</code>语言</li>
<li>并且有着和<code>Socket</code>原生一样的延迟。</li>
</ul>
<p><code>RabbitMQ</code>饿了么美团中国银行工商银行这些互联网、金融行业有着广泛的应用。</p>
<h1 id="RabbitMQ的底层原理-—-AMQP协议"><a href="#RabbitMQ的底层原理-—-AMQP协议" class="headerlink" title="RabbitMQ的底层原理 — AMQP协议"></a><code>RabbitMQ</code>的底层原理 — <code>AMQP</code>协议</h1><ul>
<li>协议就是规范，而<code>AMQP</code>协议就是<code>RabbitMQ</code>的规范，规定了<code>RabbitMQ</code>的对外接口。</li>
<li>学习<code>RabbitMQ</code>本质就是学习<code>AMQP</code>协议。</li>
</ul>
<p>生产者生产消息然后贴上<code>Routing Key</code>路由键，这个路由键就相当于快递的收件地址<code>Queue</code>。这个快递到快递分拨中心的路程我们称其为<code>Connection</code>连接。因为去往快递分拨中心肯定不止一个快递，也许有好多好多个快递正在赶往快递分拨中心，这一条条到快递分拨中心的我们称其为<code>Channel</code>叫做一条条信道。然后快递就到快递分拨中心这里，快递分拨中心在消息中间件里头叫做<code>exchange</code>就是交换机的意思，到了快递分拨中心以后，快递分拨中心要将快递分拨中心跟收件地址进行绑定不然快递员不知道从哪里拿快递，然后快递员就可以快递到收件地址<code>Queue</code>可以是蜂巢，也可以是菜鸟驿站，然后消费者就可以从菜鸟驿站中取出快递拿来消费了。消费者拿快递的通道跟生产者的一样，去往队列的路有好多条，而且此时肯定同时也有好多消费者正在前往拿快递的路上，所以就会有多个信道，这些信道放到一块就组成了连接。【连接其实就是<code>TCP</code>连接】</p>
<p>整个快递系统起主导作用的就是消息中间件，这里称呼为<code>Message Broker</code>用于接收和分发快递。因为一个<code>Broker</code>快递系统忙不过来，所以这个大大的<code>Message Broker</code>就创建了好多<code>Virtual Host</code>，就是虚拟<code>Broker</code>，将多个单元隔开。</p>
<ul>
<li>整个快递系统最核心的组件就是：快递分拨中心 —&gt; <code>Exchange</code>交换机 —&gt; 它承担了非常重要的功能即<code>RabbitMQ</code>的核心功能 —&gt; <strong>路由转发</strong></li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>使用<code>draw.io</code>绘制<code>AMQP</code>协议结构图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/9f0e5d464ed5452a89cf95226dd8ad50.png"></p>
<h1 id="RabbitMQ的心脏"><a href="#RabbitMQ的心脏" class="headerlink" title="RabbitMQ的心脏"></a><code>RabbitMQ</code>的心脏</h1><p><code>RabbitMQ</code>的整个核心就是<code>Exchange</code>交换机。</p>
<ul>
<li><p><code>Exchange</code>是<code>AMQP</code>协议和<code>RabbitMQ</code>的<strong>核心组件</strong>。</p>
</li>
<li><p><code>Exchange</code>的功能是根据<strong>路由键</strong>和<strong>绑定关系</strong>为消息提供路由，将消息转发至相应的队列。</p>
</li>
<li><p><code>Exchange</code>一共有四种类型：<code>Direct Topic Fanout Headers</code>，以前三种为主第四种使用地非常少。</p>
</li>
</ul>
<h2 id="Direct-Exchange【直连模式】"><a href="#Direct-Exchange【直连模式】" class="headerlink" title="Direct Exchange【直连模式】"></a><code>Direct Exchange</code>【直连模式】</h2><ul>
<li><p><code>Message</code>中的路由键<code>Routing Key</code>【快件地址】如果和绑定的菜鸟驿站<code>Binding Key</code>是一致的，那么【快递分拨中心】<code>Exchange</code>直接将<code>Message</code>发送到对应的队列【菜鸟驿站】<code>Queue</code>中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/13c100680a1f479b85df8138fc797b52.png"></p>
</li>
</ul>
<h2 id="Fanout-Exchange【扇形模式】"><a href="#Fanout-Exchange【扇形模式】" class="headerlink" title="Fanout Exchange【扇形模式】"></a><code>Fanout Exchange</code>【扇形模式】</h2><ul>
<li><p>每个分发到<code>Fanout Exchange</code>的消息<code>Message</code>会将消息分发到所有绑定队列<code>Queue</code>上。也就是说会发送到所有这个交换机快递分拨中心绑定的消息队列上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3c5aae51c7b64cb7b6f51ee1ea5a2bbf.png"></p>
</li>
</ul>
<h2 id="Topic-Exchange【主题模式】"><a href="#Topic-Exchange【主题模式】" class="headerlink" title="Topic Exchange【主题模式】"></a><code>Topic Exchange</code>【主题模式】</h2><ul>
<li>根据<code>Routing Key</code>以及通配规则【可以跟<code>Binding Key + #</code>匹配任意单词】，如果没有通配规则则跟直连模式一样，同时还可以跟<code>*</code>匹配一个单词。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><font color="red">推荐：模拟的<code>RabbitMQ</code>网站 —&gt; <code>http://tryrabbitmq.com/</code></font></strong></p>
<ul>
<li><code>AMQP</code>协议直接决定了<code>RabbitMQ</code>的内部结构和外部行为</li>
<li>对于发送者来说，它只关系自己的消息有没有发送到特定的【快递分拨中心】交换机<code>Exchange</code>中</li>
<li>消息通过<code>Exchange</code>路由后，到达具体的消息队列</li>
<li>消费者将消息从监听的队列中取走</li>
</ul>
<p>站在<code>Exchange</code>交换机这个快递分拨中心的角度上来，我只关心要发送的快递要发到哪里去，来寄快递的人告诉我这个快递要寄到哪里去，然后我就让指定的快递员按指定快递路线去发就可以了。所以<strong>路由键</strong><code>Routing Key</code>就是告诉快递分拨中心我要发到哪里去，而<strong>绑定关系</strong><code>Binding Key</code>就是快递分拨中心指定的快递线路。【<strong>简而言之交换机<code>Exchange</code>：不关心怎么来，只关心到哪去</strong>】</p>
<p><strong>所以说交换机<code>Exchange</code>的作用就是：<font color="red">根据路由键和绑定关系为消息提供路由，将消息转发到相应的队列中。</font></strong></p>
<h2 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h2><p>作业：在<code>tryrabbitmq.com</code>网站中，搭建<code>Direct Fanout Topic</code>三种模式的发布订阅模型。</p>
<p>第一种：<code>Direct</code>直连模式 —&gt; 张三和李四购买了咖啡，直连模式会发送到<code>1号丰巢快递柜</code>，张三李四轮询消费。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/bbbbb550e8c84ceb9bb2ee3bdfc014d2.png"></p>
<p>第二种：<code>Fanout</code>广播模式 —&gt; 奶茶店老板豪气十足，每个人都送<code>1</code>杯饮料，美团乐坏了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/27e9a634acda43fa93d69c003fe015b6.png"></p>
<p>第三种：<code>Topic</code>主题模式 —&gt;</p>
<ul>
<li>张三无论热的冰的咖啡都可以，糖分无所谓，老板做啥他喝啥，所以张三的绑定关系绑定了个<code>*.coffee</code></li>
<li>李四只喝热咖啡，糖分无所谓，所以李四的绑定关系绑定了个<code>hot.coffee</code></li>
<li>王五只喝冰咖啡，糖分无所谓，所以李四的绑定关系绑定了个<code>cold.coffee</code></li>
</ul>
<p>奶茶店老板不定时送咖啡，可以看到当老板送热咖啡的时候，张三和李四可以收到，当送冰咖啡的时候张三和王五可以收到，看来不挑食可以得到的更多哈哈</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/b62fac4d47f14594831f9f3c55d14090.png"></p>
<p>某天李四想减肥了，所以不想喝甜的咖啡了，于是李四喝咖啡的标准就是：<code>hot.unsweet.coffee</code>。</p>
<p>王五这个人呢就很喜欢吃甜食她也不介意，但是她还是想喝冰的，于是她喝咖啡的标准就成了：<code>cold.sweet.coffee</code></p>
<p>张三这个人还是一贯的不挑食不介意，冰的热的还是甜的她都可以，她就喜欢喝咖啡，没别的要求哈哈</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/b3ef7e8a0e894b9ea81d4e66f1e8615e.png"></p>
<p>这里张三<code>#.coffee</code>，这里的<code>#</code>只有在主题模式才有，表示匹配任意多个单词。</p>
<ul>
<li>当有冷的甜的咖啡的时候张三跟王五可以收到。</li>
<li>当有热的苦的咖啡的时候张三跟李四可以收到。</li>
</ul>
<h1 id="RabbitMQ快速安装"><a href="#RabbitMQ快速安装" class="headerlink" title="RabbitMQ快速安装"></a><code>RabbitMQ</code>快速安装</h1><p><code>Windows</code>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html">RabbitMQ Erlang Version Requirements — RabbitMQ</a>查找版本映射关系</li>
<li><a target="_blank" rel="noopener" href="https://www.erlang.org/">Index - Erlang&#x2F;OTP</a>下载安装<code>Erlang</code></li>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/install-windows.html">Installing on Windows — RabbitMQ</a>下载安装<code>RabbitMQ</code></li>
</ul>
<p>配置环境变量，然后直接在<code>cmd</code>中输入<code>rabbitmq-server</code>即可 —&gt; 这里的版本是<code>3.10.7</code>如果是老一点的版本，可能需要启动插件才可以在网页版中查看<code>RabbitMQ</code>消息队列。 —&gt; <code>http://localhost:15672</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins --help</span><br><span class="line">rabbitmq-plugins list </span><br><span class="line">rabbitmq-plugins rabbitmq_management</span><br></pre></td></tr></table></figure>

<p>该网页有六大模块：<strong>概览、连接、信道、交换机、队列、管理</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/7f69607850f14ac08da133260c3cbb28.png"></p>
<p>在<code>RabbitMQ</code>里头给予了一个默认的交换机即：<code>AMQP default</code>，它本质也是直连模式但是简化了直连模式的<code>Binding Key</code>，它默认<code>Binding Key</code>就是队列名。所以在这个直连模式下，你要实现发布订阅，你的路由键直接跟队列名同名即可。</p>
<h2 id="作业-2"><a href="#作业-2" class="headerlink" title="作业"></a>作业</h2><p>使用<code>RabbitMQ</code>管控台配置：直连模式、广播模式、主题模式</p>
<ul>
<li><p>我们创建三种类型的交换机，交换机是负责给通过路由键和绑定关系给消息提供路由的，分别为：美团直连模式、美团广播模式、美团话题模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/380795f57fc84014ab8fd77642641330.png"></p>
</li>
<li><p>然后创建三个队列，队列存储的是消息内容，等待消费者的消费，分别为：1号丰巢快递柜、2号丰巢快递柜、3号丰巢快递柜。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3792179435f94af2bd6a52af5a81e2da.png"></p>
</li>
</ul>
<ol>
<li><p>测试直连模式：</p>
<p>针对三个队列绑定关系为：<code>hot.coffee *.coffee cold.coffee</code></p>
<p>发送消息的路由键为：<code>hot.coffee cold.coffee</code>，发送，观察队列情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3792179435f94af2bd6a52af5a81e2da.png"></p>
<p>可以看到在直连模式下，消息发送到哪个队列，路由键跟绑定关系是绝对紧密相连的。</p>
</li>
<li><p>测试广播模式：</p>
<p>针对三个队列绑定关系为：<code>hot.coffee *.coffee cold.coffee</code></p>
<p>只发送1个消息，路由键为：<code>hot.coffee</code>，发送，观察队列情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/84e58285faff41ab803dc36ad1bf9302.png"></p>
<p>可以看到虽然只发送了一个消息而且路由键为<code>hot.coffee</code>而只有1号丰巢快递柜的绑定关系跟这个路由键相匹配，但是所有队列都收到了这个消息，这就是广播模式的发布订阅模型。</p>
</li>
<li><p>测试话题模式：</p>
<p>针对三个队列绑定关系为：<code>hot.coffee *.coffee cold.coffee</code></p>
<p>只发送1个消息，路由键为：<code>hot.coffee</code>，发送，观察队列情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2418516c68c04f088c1efe7e91c069d7.png"></p>
<p>可以看到1号跟2号收到了，但是3号没有收到，奇怪，2号的绑定关系不是<code>*.coffee</code>吗？这就是话题模式的精髓所在，它可以通过通配符的方式匹配上路由从而使队列接收到消息。</p>
</li>
</ol>
<h1 id="RabbitMQ命令行工具"><a href="#RabbitMQ命令行工具" class="headerlink" title="RabbitMQ命令行工具"></a><code>RabbitMQ</code>命令行工具</h1><ul>
<li>想看什么就<code>List</code>什么</li>
<li>想清空什么就<code>Purge</code>什么</li>
<li>想删除什么就<code>Delete</code>什么</li>
<li>一切问题记得使用<code>--help</code></li>
</ul>
<p>查看相关：	</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看状态：rabbitmqctl status</span><br><span class="line">查看连接：rabbitmqctl list_connections</span><br><span class="line">查看信道：rabbitmqctl list_channels</span><br><span class="line">查看交换机：rabbitmqctl list_exchanges</span><br><span class="line">查看绑定：rabbitmqctl list_bindings</span><br><span class="line">查看队列：rabbitmqctl list_queues</span><br><span class="line">查看消费者：rabbitmqctl list_consumers</span><br></pre></td></tr></table></figure>

<p>队列相关：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看队列：rabbitmqctl list_queues</span><br><span class="line">删除队列：rabbitmqctl delete_queue</span><br><span class="line">清空队列：rabbitmqctl purge_queue</span><br></pre></td></tr></table></figure>

<p>用户相关：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">新建用户：rabbitmqctl add_user</span><br><span class="line">修改用户密码：rabbitmqctl change_password</span><br><span class="line">删除用户：rabbitmqctl delete_user</span><br><span class="line">查看用户：rabbitmqctl list_users</span><br><span class="line">设置用户角色：rabbitmqctl set_user_tags</span><br></pre></td></tr></table></figure>

<p>应用相关：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动应用：rabbitmqctl start_app</span><br><span class="line">关闭应用保留（暂停）Erlang虚拟机：rabbitmqctl stop_app</span><br><span class="line">关闭应用并关闭Erlang虚拟机：rabbitmqctl stop</span><br></pre></td></tr></table></figure>

<p>集群相关：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加入集群：rabbitmqctl join_cluster</span><br><span class="line">离开集群：rabbitmqctl reset</span><br></pre></td></tr></table></figure>

<p>镜像队列相关：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置镜像队列：rabbitmqctl sync_queue</span><br><span class="line">取消镜像队列：rabbitmqctl cancel_sync_queue</span><br></pre></td></tr></table></figure>

<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p><code>RabbitMQ</code>高性能的原因：</p>
<ol>
<li><p>从内看：<code>Erlang</code>进程间上下文切换的效率远高于<code>C Java</code>，使得<code>RabbitMQ</code>的并发能力非常强悍</p>
</li>
<li><p>从外看：网络性能有着跟原生<code>Socket</code>一样的延迟，使得<code>RabbitMQ</code>网络<code>IO</code>性能极高</p>
</li>
</ol>
</li>
<li><p><code>RabbitMQ</code>的底层协议<code>AMQP</code>协议</p>
</li>
<li><p><code>RabbitMQ</code>的核心<code>Exchange</code></p>
</li>
</ul>
<h1 id="RabbitMQ消息交换的关键是什么？"><a href="#RabbitMQ消息交换的关键是什么？" class="headerlink" title="RabbitMQ消息交换的关键是什么？"></a><code>RabbitMQ</code>消息交换的关键是什么？</h1><p><strong>使用<code>RabbitMQ</code>本质上就是在使用<code>AMQP</code>协议</strong>，<code>AMQP</code>协议定义了<code>RabbitMQ</code>的内部结构和外部行为。</p>
<p><strong>在<code>RabbitMQ</code>中其消息转换流程如下：</strong></p>
<ul>
<li>发送者不能将消息直接发送到队列中，而需要发送给交换机</li>
<li>交换机通过路由键和绑定关系给消息提供路由，将消息转发到指定队列</li>
<li>消费者从队列中取走消息</li>
</ul>
<p><strong>合理的交换机和队列设置：</strong></p>
<ul>
<li>交换机的数量不能过多，一般来说同一个业务，或者同一类业务使用同一个交换机。</li>
<li>合理设置队列数量，一般来说一个微服务监听一个队列或者一个微服务的一个业务监听一个队列。</li>
<li>合理配置交换机类型，是同<code>Topic</code>模式的时候仔细设置绑定关系<code>Binding Key</code>以及路由键<code>Routing Key</code></li>
</ul>
<p><strong>尽量使用自动化配置：</strong></p>
<ul>
<li>将创建交换机、队列的操作固化在应用代码中，这样就可以更高效且不易出错免去了复杂的运维操作</li>
<li>一般来说，交换机由双方同时声明，队列由接收方声明并配置绑定关系</li>
<li>交换机&#x2F;队列的参数一定要由双方开发团队确认，否则重复声明时若参数不一致会导致生命失败</li>
</ul>
<p>所以关键就是：<strong>根据<code>AMQP</code>协议合理配置交换机和队列并且尽可能的时自动化部署交换机和队列。</strong></p>
<p>包括：交换机类型、交换机数量、队列数量、双方同时声明交换机跟队列</p>
<h2 id="作业-3"><a href="#作业-3" class="headerlink" title="作业"></a>作业</h2><p><strong>为什么<code>AMQP</code>要设计出<code>Exchange</code>消息流转机制呢？</strong></p>
<p>我是这样想的：</p>
<ol>
<li>设计出交换机消息流转机制，生产者跟消费者就不用关心转发的事情了，生产者只负责消费，消费者只负责消费，而有关消息转发的事情就交给<code>Exchange</code>来做，这样做可以很大程度上使<strong>系统解耦</strong>。</li>
<li>同时生产者生产完毕之后就可以不管消费者有没有去消费了，那么生产者的任务就完成了，它就可以继续干他的事情了，这就产生了<strong>异步消息处理</strong>的好处。大大省去了等待时间。</li>
<li>然后就是关于生产者生产的消息要到哪个地方【这里叫做队列】去被哪个消费者所消费，如果没有<code>Exchange</code>交换机去流转消息，那这些工作总得有人去做的，此时当然就是生产者来做了，这样肯定就会降低生产者的效率，而有了交换机可以去做流转，还可以做到<strong>消息广播</strong>跟<strong>消息收集</strong>，将消息分配到符合规则条件的队列中，并且还能做一些记录日志的工作。</li>
<li>最后就是关于流量的问题了，生产者一直负责生产，消费者一直负责消费，假设一下现在突然有了非常非常哒的流量，那么势必生产者会在一瞬间生产大量的消息，此时消费者的消费能力可能是挡不住的，作为生产者和消费者的中间着<code>Exchange</code>此时就可以发挥巨大的作用了。它可以针对这巨大的流量做<strong>流量削峰</strong>跟<strong>流量控制</strong>。</li>
</ol>
<p>所以我猜<code>AMQP</code>正是综合以上种种优点才设计出了<code>Exchange</code>消息流转机制，它有用：**<font color="red">系统解耦、异步处理、流量削峰、流量控制、消息广播、消息收集</font>**等等好处。</p>
<h2 id="14-MessageQueue"><a href="#14-MessageQueue" class="headerlink" title="14. MessageQueue"></a>14. <code>MessageQueue</code></h2><h3 id="14-1-同步通讯和异步通讯"><a href="#14-1-同步通讯和异步通讯" class="headerlink" title="14.1 同步通讯和异步通讯"></a>14.1 同步通讯和异步通讯</h3><ul>
<li><p>同步通讯：就像打电话，需要实时响应。</p>
</li>
<li><p>异步通讯：就像发邮件，不需要马上回复。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904133345.png" alt="img"></p>
<p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p>
<p>之前学习的<code>Feign</code>调用就属于同步方式，虽然调用可以实时得到结果，但是存在以下问题：<strong>耦合度高、性能下降、资源浪费、级联失败</strong>。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904133517.png" alt="img"></p>
<p><strong>同步调用的优点</strong>：时效性较强，可以实时得到结果。</p>
<p><strong>同步调用的缺点</strong>：业务代码<strong>耦合度高</strong>、一旦某个业务出现错误则整个系统都出现错误【<strong>级联失败</strong>】，需要等待调用业务完成才可以完成业务等待时间长【<strong>性能下降</strong>】，等待的时间业务仍然占用着<code>CPU</code>资源这就肯定会造成【<strong>资源浪费</strong>】。同步调用的缺点即有：<strong>耦合度高、性能下降、资源浪费、级联失败</strong>。</p>
<p><strong><font color="deepskyblue">所以为了解决同步调用：耦合度高、级联失败、性能下降、资源浪费的问题，异步调用方案就出现了。</font></strong></p>
<p>以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。在事件模式中，支付服务是事件发布者<code>publisher</code>，在支付完成之后只需要发布一个支付成功的事件<code>event</code>，事件中带上订单<code>id</code>。订单服务和物流服务是事件订阅者<code>Consumer</code>，订阅支付成功的事件，监听到事件后完成自己的业务即可。最开始是当发布者发布消息的时候，直接从线程池中拿线程来用，但是如果流量爆满，线程池中的线程总有不够用的一天，这会导致内存爆满。</p>
<p>这就是异步调用，于是为了解决异步调用线程池数量问题，就引出了**<font color="red">消息队列</font>**。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904145001.png" alt="img"></p>
<p>就是说为了解决发布者和订阅者之间的耦合度以及异步处理。中间搞了一个<code>Broker</code>，这就大大降低了系统耦合度。除了拥有<strong>系统解耦</strong>、<strong>异步处理</strong>，除此之外，<code>Broker</code>即<code>MQ</code>它还可以对过往流量进行监控，并且适当的削峰，即<strong>流量削峰</strong>、<strong>流量监控</strong>，并且对来去的消息进行<strong>消息收集</strong>和<strong>消息广播</strong>，而且还满足<strong>最终一致性</strong>即不管发布者发来什么，要消费的订阅者都会从消息队列中取数据，生产者无需管也无需担心自己发的消息没有被消费的问题。</p>
<p>总结下就是：<strong>异步处理、系统解耦、流量削峰、流量监控、消息广播、消息收集、最终一致性</strong>。</p>
<p><strong>但很明显，这样的架构变复杂了，而且你的消息队列必须做得非常安全可靠，并且支持高并发高可用。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904144714.png" alt="img"></p>
<p><strong>大多数时候，我们并不需要多线程异步处理的需求，而是追求时效性，所以大多数还是使用的是同步通讯。</strong></p>
<h3 id="14-2-消息队列"><a href="#14-2-消息队列" class="headerlink" title="14.2 消息队列"></a>14.2 消息队列</h3><p>比较常见的<code>MQ</code>实现：<code>ActiveMQ</code>、<code>RabbitMQ</code>、<code>RocketMQ</code>、<code>Kafka</code>。若是有海量数据不太关心数据安全性的果断选择<code>Kafka</code>。若需要自己做定制可以使用<code>RokcetMQ</code>大多数时候选择<code>RabbitMQ</code>即可。</p>
<table>
<thead>
<tr>
<th align="left"><strong><code>RabbitMQ</code></strong></th>
<th align="left"><strong><code>ActiveMQ</code></strong></th>
<th align="left"><strong><code>RocketMQ</code></strong></th>
<th align="left"><strong><code>Kafka</code></strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">公司&#x2F;社区</td>
<td align="left"><code>Rabbit</code></td>
<td align="left"><code>Apache</code></td>
<td align="left">阿里</td>
<td><code>Apache</code></td>
</tr>
<tr>
<td align="left">开发语言</td>
<td align="left"><code>Erlang</code></td>
<td align="left"><code>Java</code></td>
<td align="left"><code>Java</code></td>
<td><code>Scala&amp;Java</code></td>
</tr>
<tr>
<td align="left">协议支持</td>
<td align="left"><code>AMQP、XMPP、SMTP、STOMP</code></td>
<td align="left"><code>OpenWire、STOMP、REST、XMPP、AMQP</code></td>
<td align="left">自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td align="left">可用性</td>
<td align="left">高</td>
<td align="left">一般</td>
<td align="left">高</td>
<td>高</td>
</tr>
<tr>
<td align="left">单机吞吐量</td>
<td align="left">一般</td>
<td align="left">差</td>
<td align="left">高</td>
<td>非常高</td>
</tr>
<tr>
<td align="left">消息延迟</td>
<td align="left">微秒级</td>
<td align="left">毫秒级</td>
<td align="left">毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td align="left">消息可靠性</td>
<td align="left">高</td>
<td align="left">一般</td>
<td align="left">高</td>
<td>一般</td>
</tr>
</tbody></table>
<p>有没想过为什么<code>RabbitMQ</code>的消息延迟可以做到微秒级？这正是因为<code>RabbitMQ</code>是基于<code>Erlang</code>语言开发的。</p>
<ul>
<li>它是 一款专门为交换机软件开发的语言，而且是分布式的面向并发的。</li>
<li><code>Erlang</code>可以做到进程间上下文切换效率远高于<code>C</code>语言。</li>
<li><code>Erlang</code>还有者跟原生<code>Socket</code>一样的延迟。</li>
<li><code>Erlang</code>是虚拟机解释运行的语言所以可以跨平台部署<code>RabbitMQ</code>。</li>
</ul>
<h3 id="14-3-使用Docker安装RabbitMQ"><a href="#14-3-使用Docker安装RabbitMQ" class="headerlink" title="14.3 使用Docker安装RabbitMQ"></a>14.3 使用<code>Docker</code>安装<code>RabbitMQ</code></h3><ol>
<li><p>拉取<code>RabbitMQ</code>镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>RabbitMQ</code>容器，用户名：<code>admin</code>，密码：<code>123456</code>，容器名：<code>RabbitmqContainer</code>，服务端口<code>5672</code>，<code>web</code>管理端口<code>15672</code>，主机名：<code>mq1</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 --name RabbitMQContainer --hostname rabbitmq -p 15672:15672 -p 5672:5672 -d rabbitmq:3-management</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>VirtualBox</code>配置端口映射<code>15672</code>然后访问地址：<code>http://192.168.56.1:15672</code>即可</p>
</li>
</ol>
<h3 id="14-4-RabbitMQ中的角色及其基本结构"><a href="#14-4-RabbitMQ中的角色及其基本结构" class="headerlink" title="14.4 RabbitMQ中的角色及其基本结构"></a>14.4 <code>RabbitMQ</code>中的角色及其基本结构</h3><ul>
<li><code>publisher</code>：生产者【寄件人】</li>
<li><code>consumer</code>：消费者【收件人】</li>
<li><code>exchange</code>：交换机，负责消息路由【快件分拨中心】</li>
<li><code>queue</code>：队列，存储消息【丰巢快递柜】</li>
<li><code>virtualHost</code>：虚拟主机，<strong>隔离不同租户</strong>的<code>exchange</code>、<code>queue</code>、消息隔离</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904172912.png" alt="img"></p>
<h3 id="14-5-RabbitMQ的底层实现原理：AMQP协议"><a href="#14-5-RabbitMQ的底层实现原理：AMQP协议" class="headerlink" title="14.5 RabbitMQ的底层实现原理：AMQP协议"></a>14.5 <code>RabbitMQ</code>的底层实现原理：<code>AMQP</code>协议</h3><ul>
<li>协议就是规范，而<code>AMQP</code>协议就是<code>RabbitMQ</code>的规范，规定了<code>RabbitMQ</code>的对外接口。</li>
<li>学习<code>RabbitMQ</code>本质就是学习<code>AMQP</code>协议。</li>
</ul>
<blockquote>
<ol>
<li>生产者生产消息然后贴上<code>Routing Key</code>路由键，这个路由键就相当于快递的收件地址<code>Queue</code>。</li>
<li>这个快递到快递分拨中心的路程我们称其为<code>Connection</code>连接。因为去往快递分拨中心肯定不止一个快递，也许有好多好多个快递正在赶往快递分拨中心，这一条条到快递分拨中心的我们称其为<code>Channel</code>叫做一条条信道。</li>
<li>然后快递就到快递分拨中心这里，快递分拨中心在消息中间件里头叫做<code>exchange</code>就是交换机的意思。</li>
<li>到了快递分拨中心以后，快递分拨中心要将快递分拨中心跟收件地址进行绑定不然快递员不知道从哪里拿快递，然后快递员就可以快递到收件地址<code>Queue</code>可以是蜂巢，也可以是菜鸟驿站。</li>
<li>随后消费者就可以从菜鸟驿站中取出快递拿来消费使用了。</li>
<li>消费者拿快递的通道跟生产者的一样，去往队列的路有好多条，而且此时肯定同时也有好多消费者正在前往拿快递的路上，所以就会有多个信道，这些信道放到一块就组成了连接。【连接其实使用的就是<code>TCP</code>连接】</li>
<li>整个快递系统起主导作用的就是消息中间件，这里称呼为<code>Message Broker</code>用于接收和分发快递。</li>
<li>因为一个<code>Broker</code>快递系统忙不过来，所以这个大大的<code>Message Broker</code>就创建了好多<code>Virtual Host</code>，就是虚拟<code>Broker</code>，将多个单元隔开。</li>
</ol>
</blockquote>
<p>整个快递系统最核心的组件就是：快递分拨中心 —&gt; <code>Exchange</code>交换机 —&gt; 它承担了非常重要的功能即<code>RabbitMQ</code>的核心功能 —&gt; <strong>路由转发</strong>：<code>Exchange</code>根据路由键<code>Routing Key</code>和绑定关系<code>Binding Key</code>为消息提供路由，将消息转发至相应队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/9f0e5d464ed5452a89cf95226dd8ad50.png"></p>
<h3 id="14-6-RabbitMQ官方模型介绍"><a href="#14-6-RabbitMQ官方模型介绍" class="headerlink" title="14.6 RabbitMQ官方模型介绍"></a>14.6 <code>RabbitMQ</code>官方模型介绍</h3><p><code>RabbitMQ</code>官方提供了<code>5</code>个不同的<code>Demo</code>示例，对应了不同的消息模型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904173739.png" alt="img"></p>
<h3 id="14-7-RabbitMQ官方API实现HelloWorld模型"><a href="#14-7-RabbitMQ官方API实现HelloWorld模型" class="headerlink" title="14.7 RabbitMQ官方API实现HelloWorld模型"></a>14.7 <code>RabbitMQ</code>官方<code>API</code>实现<code>HelloWorld</code>模型</h3><p>非常非常简单的发布订阅模型，就是发布者将消息发布到队列中然后消费者从队列中取出消息进行消费。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904200637.png" alt="img"></p>
<p>官方的<code>HelloWorld</code>是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li><code>publisher</code>：消息发布者，将消息发送到队列<code>queue</code></li>
<li><code>queue</code>：消息队列，负责接受并缓存消息</li>
<li><code>consumer</code>：订阅队列，处理队列中的消息</li>
</ul>
<p>使用<code>RabbitMQ</code>官方提供的<code>API</code>即可实现这一模型：</p>
<ol>
<li><p>引入依赖主要就是<code>spring-boot-starter-amqp</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>message-queue-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>02-message-queue-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>02-message-queue-demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建发布者测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.publisher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HelloWorldTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.56.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.创建连接通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//4.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;hello.world.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//5.发布消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World Type RabbitMQ&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">//6.关闭通道，关闭连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动测试类，然后观察<code>http://192.168.56.1:15672/#/queues</code>中的队列情况。</p>
</li>
<li><p>创建消费者测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.publisher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HelloWorldTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.56.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.创建连接通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//4.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;hello.world.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//5.发布消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World Type RabbitMQ&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">//6.关闭通道，关闭连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动测试类，然后观察<code>http://192.168.56.1:15672/#/queues</code>中的队列情况以及控制台消息，可以看到控制台中打印了消息并且消息队列中的消息被消费了。</p>
</li>
</ol>
<h3 id="14-8-SpringAMQP实现发布订阅模型"><a href="#14-8-SpringAMQP实现发布订阅模型" class="headerlink" title="14.8 SpringAMQP实现发布订阅模型"></a>14.8 <code>SpringAMQP</code>实现发布订阅模型</h3><p><code>SpringAMQP</code>是基于<code>RabbitMQ</code>封装的一套模板，并且还利用 <code>SpringBoot</code>对其实现了自动装配，使用起来非常方便。<code>SpringAMQP</code>的官方地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-amqp%E3%80%82">https://spring.io/projects/spring-amqp。</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904202046.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904202056.png" alt="img"></p>
<p><code>SpringAMQP</code>提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了<code>RabbitTemplate</code>工具，用于发送消息</li>
</ul>
<h4 id="14-8-1-Hello-World"><a href="#14-8-1-Hello-World" class="headerlink" title="14.8.1 Hello-World"></a>14.8.1 <code>Hello-World</code></h4><p>使用<code>Spring AMQP</code>实现<code>Hello-World</code>发布订阅模型：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904211238.png" alt="img"></p>
<ol>
<li><p>消费者和生产者都需要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者和生产者都需要修改配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者使用<code>RabbitTemplate</code>发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.publisher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAMQPTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimple</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;hello.world.queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;人类毁于傲慢。&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者监听消费：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;hello.world.queue&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimple</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="14-8-2-Work-Queue"><a href="#14-8-2-Work-Queue" class="headerlink" title="14.8.2 Work-Queue"></a>14.8.2 <code>Work-Queue</code></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904211238.png" alt="img"></p>
<p>使用<code>Spring AMQP</code>实现<code>Work-Queue</code>发布订阅模型：</p>
<p><code>Work queues</code>，也被称为<code>（Task queues）</code>，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息【轮询消费】</strong>。</p>
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用<code>work</code>模型，多个消费者共同处理消息处理，速度就能大大提高了。</p>
<ol>
<li><p>声明一个队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">workQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;work.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;work.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;世界人民 --- &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, (message + i));</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;hello.world.queue&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimple</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;work.queue&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWork1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者...1...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;work.queue&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWork2</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者...2...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>启动测试、消费者项目，可以看到不同的消费者轮询消费队列中的消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">消费者...2...消费消息：世界人民 --- 0</span><br><span class="line">消费者...1...消费消息：世界人民 --- 1</span><br><span class="line">消费者...2...消费消息：世界人民 --- 2</span><br><span class="line">消费者...1...消费消息：世界人民 --- 3</span><br><span class="line">消费者...2...消费消息：世界人民 --- 4</span><br><span class="line">消费者...1...消费消息：世界人民 --- 5</span><br><span class="line">消费者...2...消费消息：世界人民 --- 6</span><br><span class="line">消费者...1...消费消息：世界人民 --- 7</span><br><span class="line">消费者...2...消费消息：世界人民 --- 8</span><br><span class="line">消费者...1...消费消息：世界人民 --- 9</span><br><span class="line">消费者...2...消费消息：世界人民 --- 10</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这样的消费者轮询消费并没有考虑到不同消费者可能存在不同的处理能力。<code>RabbitMQ</code>默认有一个消息预取机制，还没消费就会预取下一个消息到下一个消费者手中，通过<code>prefetch</code>可以实现限制每次只能取1条消息，消费完毕后才能取下一个消息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>Work</code>模型的使用：</p>
<ul>
<li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li>
<li>通过设置<code>prefetch</code>来控制消费者预取的消息数量</li>
</ul>
<h4 id="14-8-3-Fanout"><a href="#14-8-3-Fanout" class="headerlink" title="14.8.3 Fanout"></a>14.8.3 <code>Fanout</code></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210904213455.png" alt="img"></p>
<p>图中可以看到，在订阅模型中，多了一个<code>exchange</code>角色，而且过程略有变化</p>
<ul>
<li><code>Publisher</code>：生产者，也就是要发送消息的程序，但是不再发送到队列中，<strong>而是发给<code>exchange</code>（交换机）</strong></li>
<li><code>Consumer</code>：消费者，与以前一样，订阅队列，没有变化</li>
<li><code>Queue</code>：消息队列也与以前一样，接收消息、缓存消息</li>
<li><code>Exchange</code>：交换机，一方面，接收生产者发送的消息；另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于<code>Exchange</code>的类型。<code>Exchange</code>有以下<code>3</code>种类型：<ul>
<li><code>Fanout</code>：广播，将消息交给所有绑定到交换机的队列</li>
<li><code>Direct</code>：定向，把消息交给符合指定<code>routing key</code>的队列</li>
<li><code>Topic</code>：通配符，把消息交给符合<code>routing pattern</code>（路由模式） 的队列</li>
</ul>
</li>
</ul>
<p><strong><code>Exchange</code>（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与<code>Exchange</code>绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<p><code>Fanout</code>，英文翻译是扇出，在<code>MQ</code>中我们也可以称为广播。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210912160350.png" alt="img"></p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>可以有多个队列</li>
<li>每个队列都要绑定到<code>Exchange</code>（交换机）</li>
<li>生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>交换机把消息发送给绑定过的所有队列</li>
<li>订阅队列的消费者都能拿到消息</li>
</ul>
<ol>
<li><p>声明一个广播类型的交换机以及三个队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanout.exchange&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout2.queue2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">fanoutQueue3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定交换机跟队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingFanoutQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingFanoutQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingFanoutQueue3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue3()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行项目，可以查看到交换机绑定了三个队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/938201a6be6b450dad10196d7c2b779b.png" alt="img"></p>
</li>
<li><p>消费者监听三个队列，实时消费：[创建三个消费者]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFanoutConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout.queue1&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanout1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;广播模式...消费者...1...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout.queue2&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanout2</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;广播模式...消费者...2...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;fanout.queue3&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanout3</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;广播模式...消费者...3...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者发布消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Fanout Message&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;fanout.exchange&quot;</span>, <span class="string">&quot;&quot;</span>, message.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行项目，查看结果：可以看到虽然只生产了<code>1</code>条消息，但是在广播模式下，发送给了3个队列，丝毫不用理会<code>Routing Key</code>，这就是广播模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">广播模式...消费者..<span class="number">.1</span>...消费消息：Fanout Message</span><br><span class="line">广播模式...消费者..<span class="number">.3</span>...消费消息：Fanout Message</span><br><span class="line">广播模式...消费者..<span class="number">.2</span>...消费消息：Fanout Message</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了使用配置类的方式配置绑定关系，还可以使用注解的方式配置绑定关系，声明新的队列</p>
<p>这里的<code>type = &quot;fanout&quot;</code>是一定要写的，因为默认是<code>direct</code>直连模式类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;fanout.queue4&quot;), exchange = @Exchange(value = &quot;fanout.exchange&quot;, type = &quot;fanout&quot;))&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanout4</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;广播模式...消费者...4...消费消息：&quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="14-8-4-Direct"><a href="#14-8-4-Direct" class="headerlink" title="14.8.4 Direct"></a>14.8.4 <code>Direct</code></h4><p>在<code>Fanout</code>模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到<code>DirectExchange</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210912182822.png" alt="img"></p>
<p>在<code>Direct</code>模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由<code>key</code>）</li>
<li>消息的发送方向<code>Exchange</code>发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li><code>Exchange</code>不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<ol>
<li><p>声明直连交换机、3个队列、绑定交换机跟队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;direct.exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDirectQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1()).to(directExchange()).with(<span class="string">&quot;cold.coffee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDirectQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2()).to(directExchange()).with(<span class="string">&quot;hot.coffee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDirectQueue3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue3()).to(directExchange()).with(<span class="string">&quot;spicy.coffee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建生产者发送消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Direct Cold Coffee Message&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;direct.exchange&quot;</span>, <span class="string">&quot;cold.coffee&quot;</span>, message.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建消费者消费消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDirectConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;direct.queue1&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirect1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者 ① 消费消息 冷咖啡：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;direct.queue2&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirect2</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者 ② 消费消息 热咖啡：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;direct.queue3&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirect3</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者 ③ 消费消息 辣咖啡：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行项目，可以发现只有消费者<code>1</code>消费了消息，因为生产者发送的<code>Routing Key ---&gt; cold.coffee</code>，而绑定关系也是<code>cold.coffee</code>，所以就只有消费者<code>1</code>消费了消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直连模式 Direct 消费消息 冷咖啡：Direct Cold Coffee Message</span><br></pre></td></tr></table></figure>

<p>可以尝试改成<code>hot.coffee</code>，那就只有消费者<code>2</code>消费了消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直连模式 Direct 消费消息 冷咖啡：Direct Cold Coffee Message</span><br><span class="line">直连模式 Direct 消费消息 热咖啡：Direct Hot Coffee Message</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用注解创建第四个队列并与<code>direct.exchange</code>交换机绑定，绑定关系有两个<code>sweet.coffee</code>和<code>hot.coffee</code>，所以当发送的路由键为<code>hot.coffee</code>，理应第二个队列跟第四个队列都收得到其余队列收不到，而为<code>sweet.coffee</code>时只有第四个队列消费得了消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;direct.queue4&quot;), exchange = @Exchange(value = &quot;direct.exchange&quot;, type = &quot;direct&quot;), key = &#123;&quot;sweet.coffee&quot;, &quot;hot.coffee&quot;&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirect4</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者 ④ 消费消息 热咖啡和甜咖啡：&quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行项目，结果与预期一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消费者 ④ 消费消息 热咖啡和甜咖啡：Direct Hot Coffee Message</span><br><span class="line">消费者 ② 消费消息 热咖啡：Direct Hot Coffee Message</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="14-8-5-Topic"><a href="#14-8-5-Topic" class="headerlink" title="14.8.5 Topic"></a>14.8.5 <code>Topic</code></h4><p><code>Topic </code> 与 <code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic </code>类型可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xn2001.com/img/2021/20210912194016.png" alt="img"></p>
<p>通配符规则：</p>
<p><code>#</code>：匹配一个或多个词</p>
<p><code>*</code>：只能匹配一个词</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.#`：能够匹配 item.spu.insert 或者 item.spu</span><br><span class="line">item.*`：只能匹配 item.spu</span><br></pre></td></tr></table></figure>

<p>将上述图例转化为代码，全部使用注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTopicConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;topic.queue1&quot;), exchange = @Exchange(value = &quot;topic.exchange&quot;, type = &quot;topic&quot;), key = &#123;&quot;china.#&quot;&#125;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopic1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者...1...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;topic.queue2&quot;), exchange = @Exchange(value = &quot;topic.exchange&quot;, type = &quot;topic&quot;), key = &#123;&quot;japan.#&quot;&#125;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopic2</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者...2...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;topic.queue3&quot;), exchange = @Exchange(value = &quot;topic.exchange&quot;, type = &quot;topic&quot;), key = &#123;&quot;#.weather&quot;&#125;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopic3</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者...3...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;topic.queue4&quot;), exchange = @Exchange(value = &quot;topic.exchange&quot;, type = &quot;topic&quot;), key = &#123;&quot;#.news&quot;&#125;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopic4</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者...4...消费消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Direct china.weather.news Message&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;topic.exchange&quot;</span>, <span class="string">&quot;china.weather.news&quot;</span>, message.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消费者..<span class="number">.1</span>...消费消息：Direct china.weather.news Message</span><br><span class="line">消费者..<span class="number">.4</span>...消费消息：Direct china.weather.news Message</span><br></pre></td></tr></table></figure>

<h3 id="14-9-消息转换器"><a href="#14-9-消息转换器" class="headerlink" title="14.9 消息转换器"></a>14.9 消息转换器</h3><p><code>Spring</code>会把你发送的消息序列化为字节发送给<code>MQ</code>，接收消息的时候，还会把字节反序列化为<code>Java</code>对象。</p>
<p><strong>默认情况下<code>Spring</code>采用的序列化方式是<code>JDK</code>序列化。</strong></p>
<p>我们可以去试一下效果：直接发送一个<code>Map</code>类型的数据给<code>object.queue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObjectConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = &#123;@Queue(value = &quot;object.queue&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopic1</span><span class="params">(Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收 Map 消息：&quot;</span> + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先停止消费者【先启动消费者是为了创建队列】，然后生产者发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObject</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/535f76d79afb4f5d8b80785fcaf09f64.png" alt="img"></p>
<p>可以看到发送的消息体积非常大，可读性很差，所以推荐使用<code>JSON</code>格式进行序列化和反序列化。</p>
<ol>
<li><p>生产者和消费者均引入：<code>jackson</code>依赖</p>
</li>
<li><p>生产者和消费者均添加配置类，修改消息转换器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时再发送和接收消息就靠的是<code>jackson</code>来进行消息转换了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/86f249d02d9a44d19731c695645c1354.png" alt="img"></p>
</li>
</ol>
<h2 id="20-服务异步通讯"><a href="#20-服务异步通讯" class="headerlink" title="20. 服务异步通讯"></a>20. 服务异步通讯</h2><h3 id="20-1-传统MQ的问题"><a href="#20-1-传统MQ的问题" class="headerlink" title="20.1 传统MQ的问题"></a>20.1 传统<code>MQ</code>的问题</h3><p>以前学习的<code>MQ</code>感觉已经很不错了，但其实还是有一些问题我们并不明白消息队列是如何作保障的：</p>
<ol>
<li><strong>消息可靠性的问题：</strong>如何确保发送的消息至少被消费一次</li>
<li><strong>延迟消费问题：</strong>这其实是业务上的问题了，就是如何实现消息的延迟投递即我怎么才能到点发送消息</li>
<li><strong>消息堆积问题：</strong>如何解决数百万消息堆积，无法及时消费的问题</li>
<li><strong>高可用问题：</strong>如何避免单点<code>MQ</code>故障而导致整个消息订阅模型不可用的问题</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/92ccf280e4ba499080ffe33af5eb8a82.png" alt="img"></p>
<h3 id="20-2-消息可靠性"><a href="#20-2-消息可靠性" class="headerlink" title="20.2 消息可靠性"></a>20.2 消息可靠性</h3><p>我们现在来解决第一大问题，如何确保消息队列发布订阅过程是可靠的？也就是如何确保从生产者生产的消息一定到了消费者手中被他所消费呢？</p>
<p>我们知道消息从被发送到消费者接收，中间会经历很多个过程，大体过程如下图：消息从发布者到消费者，可能丢失的地方在：</p>
<ol>
<li>发布者到交换机的中途中</li>
<li>交换机到消息队列的中途中</li>
<li>消息队列宕机，因为消息对立而是基于内存的所以导致存储的消息丢失</li>
<li>消费者自身还没来得及消费就宕机了导致数据丢失</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/22de4b7b4d4b4d90b6834851678b9fba.png" alt="img"></p>
<p>所以消息丢失可以分为三种类型：【完全就是按消息经历过程来分类的】</p>
<ol>
<li>发送时丢失<strong>【生产者导致丢失】</strong><ul>
<li>生产者<code>publisher</code>发送的消息没有送达到交换机<code>exchange</code></li>
<li>消息到达交换机<code>exchange</code>却没有到达消息队列<code>MessageQueue</code></li>
</ul>
</li>
<li><code>MQ</code>宕机导致消息队列中的消息丢失<strong>【<code>MQ</code>导致丢失】</strong></li>
<li>消费者<code>consumer</code>接收到消息之后还没来得及消费就宕机了导致消息丢失<strong>【消费者导致丢失】</strong></li>
</ol>
<p>所以保证消息的可靠性，其本质就是解决上述可能存在的消息丢失问题即：发送过程丢失、消息队列宕机导致丢失、消费者宕机导致丢失。</p>
<h4 id="20-2-1-MQ如何解决发送路上的丢失"><a href="#20-2-1-MQ如何解决发送路上的丢失" class="headerlink" title="20.2.1 MQ如何解决发送路上的丢失"></a>20.2.1 <code>MQ</code>如何解决发送路上的丢失</h4><p>发送路上有两种情况会导致数据丢失，一是消息在发布者到达交换机的路上丢失，二是消息在交换机到达队列的路上丢失。它们都可以使用<code>RabbitMQ</code>提供的<strong>生产者确认机制</strong>即<code>publisher confirm</code>来确保消息传递的可靠性，该机制就可以避免消息发送到交换机的过程中丢失。</p>
<ul>
<li><p><strong>我们先来看生产确认机制如何解决第一种：<font color="red">生产者到交换机路上的丢失</font></strong> <code>publisher-confirm</code></p>
<p>当消息发送到交换机之后会返回一个结果给发送者，表示消息是否处理成功，因为交换机是属于<code>MQ</code>的一部分，所以返回处理结果给发送者这一工作会交给<code>MQ</code>来完成，<code>MQ</code>在发送者到交换机的这一过程返回<code>publisher-confirm</code>发送者确认，这其中发送者确认又分两种情况：</p>
<ul>
<li>消息成功投递到投递到了交换机，返回<code>ACK</code>确认信号[<code>acknowledge</code>]</li>
<li>消息没有投递到交换机，返回<code>NACK</code>不确认信号</li>
</ul>
</li>
<li><p><strong>然后再来看生产确认机制如何解决第二种：<font color="red">交换机到达队列路上的丢失</font></strong> <code>publisher-return</code></p>
<p>在消息从交换机推送到队列的这一过程失败后，说明路由失败，生产确认机制就会返回发送者回执<code>publisher-return</code></p>
<ul>
<li>消息投递到了交换机但是没有路由到队列。返回<code>ACK</code> + 路由失败原因。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/47ad3a2943a94304be22ac54ec624d90.png" alt="img"></p>
<p>上面确实可以让生产者知道有消息在发送到队列<code>Queue</code>的过程中丢失的问题，但问题是，生产者怎么知道丢失或者确认收到的是哪条消息呢？所以我们要在生产者确认机制发送的确认消息即<code>MQ</code>发送的<code>publisher-confirm/publisher-return</code>里面设置一个唯一的标识即全局唯一<code>id</code>，以区分不同消息，避免<code>ack</code>冲突。</p>
<p>总结起来就是一句话：**<code>MQ</code>会通过生产确认机制确保消息发送过程的可靠性。**</p>
<p>为了演示生产者确认机制，需要先搭建一个<code>demo</code>项目，因为这学习的正是<code>MQ</code>高级部分，所以项目名称取名为：<code>mq-advanced-demo</code>。直接导入即可。然后需要在<code>docker</code>安装<code>rabbitmq</code>，记得对外开放端口：<code>5672 15672</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name rabbitmq -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -v /var/lib/docker/volumes/mq-plugins/_data:/usr/local/src -d rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>

<ol>
<li><p>开启消息队列的生产者确认机制 —&gt; 修改配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>配置信息说明如下：</p>
<ul>
<li><code>publisher-confirm-type</code>：开启<code>publisher-confirm</code>，有两种类型：<ul>
<li><code>simple</code>：意思就是生产者发送完消息以后<strong>同步等待</strong>消息队列<code>MQ</code>的<code>publisher-confirm</code>结果，直到等到为止，如果没等到就一直等到超时，这种方式会导致代码的阻塞</li>
<li><code>correlated</code>：<strong>异步回调</strong>，自定义<code>ConfirmCallback</code>，<code>MQ</code>返回结果时会调用这个回调类<code>ConfirmCallback</code>，这样生产者就不用一直等待了，发完这条消息就继续干它的事情比如发送下一条消息，有结果了就拿来看看，然后做处理。</li>
</ul>
</li>
<li><code>publisher-return</code>：<strong>开启<code>publisher-return</code>功能</strong>，同样是基于<code>callback</code>回调机制，不过定义的回调类实现的接口为<code>ReturnCallback</code>。</li>
<li><code>template.mandatory</code>：定义消息路由失败时的策略，<code>publisher-return</code>只是告知发送者说这个消息丢失了，但是发送者要怎么处理消息路由失败还没说，这个就是用来说明策略的，如果为<code>true</code>就会调用<code>ReturnCallback</code>实现方法，如果为<code>false</code>则会直接丢弃消息</li>
</ul>
</li>
<li><p>编写<code>publisher-confirm</code>回调函数：<code>ConfirmCallback</code></p>
<p><code>ConfirmCallback</code>可以在发送消息时指定，因为每个业务处理<code>confirm</code>成功或失败的逻辑不一定相同。</p>
<p>在<code>publisher</code>服务的<code>com.kk.mq.spring.SpringAmqpTest</code>类中，定义一个单元测试方法：</p>
<p><strong><font color="red">注：我这里跟源代码提供的<code>log</code>等级不一样，他的是<code>debug error</code>，我这里是<code>info</code>，因为我要显示后续效果，否则打印不出来。</font></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Spring AMQP!&quot;</span>;</span><br><span class="line">    <span class="comment">//这里的 UUID.randomUUID().toString() 的意思是定义唯一全局 ID</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">//添加回调函数</span></span><br><span class="line">    correlationData.getFuture().addCallback(result -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息从发送者到交换机的过程成功，ID:&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送者到交换机的过程消息丢失，消息发送到路由器失败, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>, correlationData.getId(), result.getReason());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, throwable -&gt; &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息从发送者到交换机的过程中发生异常, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>, correlationData.getId(), throwable.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;task.direct&quot;</span>, <span class="string">&quot;task&quot;</span>, message, correlationData);</span><br><span class="line">    <span class="comment">//等待 ACK 回执</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写<code>ReturnCallback</code>回调函数，用于<code>publisher-return</code>发送回执，如果在消息要从交换机到达队列的过程消息丢失，就会调用这个<code>ReturnCallback</code>回调函数 —&gt; 该回调函数需要通过<code>RabbitTemplate</code>来设置，所以需要在应用启动式，<code>Bean</code>工厂创建好之后创建好回调函数<code>ReturnCallback</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换第到队列的过程消息丢失，发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;，消息&#123;&#125;&quot;</span>, replyCode, replyText, exchange, routingKey, message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先来测试下<code>ConfirmCallback</code>中消息在发送者到交换机之间丢失的情况，浏览器输入<a href="http://192.168.56.1:15672登录`RabbitMQ`的`Web`管理界面【后面都是这样，不再赘述】，可以看到没有`task.direct`的交换机，所以消息是到达不了交换机的，我们此时点击发送：">http://192.168.56.1:15672登录`RabbitMQ`的`Web`管理界面【后面都是这样，不再赘述】，可以看到没有`task.direct`的交换机，所以消息是到达不了交换机的，我们此时点击发送：</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/9e662aef88c141dfbc02b57ac427acf9.png" alt="img"></p>
<p>观察<code>IDEA</code>中返回的情况：可以发现确实触发了生产确认机制调用了<code>ConfirmCallback</code>，然后发送了丢失的消息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/9286a9472d004882a5006c7d75a8624c.png" alt="img"></p>
</li>
<li><p>再来看下如果有交换机，但是没有队列的情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e3664376f306496fb9345e1ace995b9c.png" alt="img"></p>
<p>发送消息，查看结果：可以看到调用了发送消息时<code>CorrelationData</code>设置的<code>ConfrimCallback</code>回调函数以及在<code>CommonConfig</code>中应用启动时设置的<code>ReturnCallback</code>回调函数。可以看到消息到达了交换机但是在交换机到队列中的过程丢失了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/90d65cdbd4164b90b3dc3252d1f2e95d.png" alt="img"></p>
</li>
<li><p>再继续创建好队列，绑定交换机<code>direct.task</code>以及路由<code>task</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2418e9508c4442f6a04f44610fbaca3c.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3f82fe8b5d14472f9f0fbf3fd7f6f0c2.png" alt="img"></p>
<p>然后发送消息查看结果：可以看到控制台没有返回任何信息，查看队列可以看到队列中已经有消息了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/73036919f58d4c3589cb89206dffe7b0.png" alt="img"></p>
<p>点击<code>Queue</code>界面中的<code>Get Message</code>，可以看到确实是我们在<code>Java</code>中所发送的消息：<code>Hello, Spring AMQP!</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/c9e24c7d5caa4e44900c9a88499c99c4.png" alt="img"></p>
</li>
</ol>
<p><strong><font color="deepskyblue">到这里，确保消息在发送过程中：包括从发送者到交换机、交换机到队列不会丢失就已经学习完成了 —&gt; 使用的是</font><font color="red">发送者确认机制</font>。</strong></p>
<p>总结：</p>
<ul>
<li><code>SpringAMQP</code>中处理消息确认的几种情况：<ul>
<li><code>publisher-confirm</code><ol>
<li>消息成功从发送者手中发送到交换机，返回<code>ACK</code></li>
<li>消息从发送者手发送给交换机的过程失败，返回<code>NACK</code></li>
<li>消息在发送过程中发生异常没有收到任何回执返回异常处理</li>
</ol>
</li>
<li><code>publisher-return</code><ol>
<li>消息从交换机发送给队列的过程失败，返回<code>ACK + 路由失败原因</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="20-2-2-MQ如何解决MQ宕机导致数据丢失"><a href="#20-2-2-MQ如何解决MQ宕机导致数据丢失" class="headerlink" title="20.2.2 MQ如何解决MQ宕机导致数据丢失"></a>20.2.2 <code>MQ</code>如何解决<code>MQ</code>宕机导致数据丢失</h4><p>上一小节我们学习了如何避免消息在发送过程丢失的问题，此时消息就会到达本站<code>RabbitMQ</code>手中，准确地说是已经投递到了消费者要消费的队列中，那如果此时<code>RabbitMQ</code>宕机了咋办，我们知道<code>MQ</code>中的数据是存储在内存中，那这样岂不是数据都丢失了？</p>
<p>想想还有什么跟<code>MQ</code>很像，数据也是存储在内存之中的呢？没错，就是<code>Redis</code>，当时我们是如何解决<code>Redis</code>数据丢失的问题的呢？没错，正是那个宝贝 —— 持久化！！！</p>
<p>所以针对消息队列为了避免消息丢失，我们需要做**<font color="red">消息持久化</font>font&gt;**。</p>
<p>创建的消息队列和交换机的时候，创建的时候默认它们就是持久的这个也可以在创建的是否，若是<code>Java</code>代码可以通过设置<code>true / false</code>来设置是否<code>Durable</code>即持久化，若是<code>Web</code>管理界面可设置<code>Durability</code>中<code>Transient</code>是否是短暂的还是<code>Durable</code>持久的来设置交换机或者队列的持久化。</p>
<p>重点是消息的持久化，<code>SpringAMQP</code>默认会将消息持久化，所以就算我们重启<code>RabbitMQ</code>也可以在队列中照常看到消息。</p>
<p>可以通过<code>MessageBuidler</code>创建<code>Message</code>对象，使得该消息不被持久化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody(message.getBytes(StandardCharsets.UTF_8)).setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT).build();</span><br></pre></td></tr></table></figure>

<p>点击<code>IDEA</code>发送消息然后：可以看到此时队列是有消息的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/b72557138f824fb48e0e8e63598160b5.png" alt="img"></p>
<p>然后重启<code>Docker rabbitmq</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker restart rabbitmq</span><br><span class="line">docker logs -f rabbitmq</span><br></pre></td></tr></table></figure>

<p>可以发现这时队列中的消息不见了，正是因为消息没有做持久化：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4825626e15374f47b0f6d8e6c9a0fbad.png" alt="img"></p>
<p>如果将<code>MessageBuilder</code>中的<code>setDeliveryMode</code>更改为<code>MessageDeliveryMode.PERSISTENT</code>或者干脆直接发送<code>message</code>而不是<code>msg</code>【通过<code>MessageBuilder</code>创建】因为默认<code>SpringAMQP</code>就已经实现了消息持久化了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/b72557138f824fb48e0e8e63598160b5.png" alt="img"></p>
<h4 id="20-2-3-MQ如何解决消费者宕机导致数据丢失"><a href="#20-2-3-MQ如何解决消费者宕机导致数据丢失" class="headerlink" title="20.2.3 MQ如何解决消费者宕机导致数据丢失"></a>20.2.3 <code>MQ</code>如何解决消费者宕机导致数据丢失</h4><p>通过前面两个小节的学习就知道了消息队列通过发送者确认机制以及交换机、队列、消息的持久化实现了消息发送过程【发送者—&gt;交换机，交换机—&gt;队列】、队列的可靠性。</p>
<p>到了这一步就是消息从队列发送到消费者，消费者消费消息了。那么在这里，<code>MQ</code>又该如何在消费者这里完成它的可靠性呢？如何防止在消费者消费之前的那一刻消费者宕机了导致消息丢失呢？这就需要使用到**<font color="red">阅后即焚机制</font>**。</p>
<p>阅后即焚机制：消费者会向<code>RabbitMQ</code>发送<code>ACK</code>回执，表明自己已经处理了消息，然后<code>RabbitMQ</code>接收到该<code>ACK</code>回执后会删除队列中的消息。</p>
<p>但是什么时候发送<code>ACK</code>回执呢？</p>
<ul>
<li>是在消息还没到消费者手里就发送吗？显然不是</li>
<li>那是在消息到了消费者手中就立马发送吗？当然也不是，万一还没消费消息就删除了，不也无法实现可靠性嘛</li>
<li>那是在消息到了消费者手中并被消费了然后发送吗？没错就是这个了</li>
</ul>
<p><code>SpringAMQP</code>提供了三种消费者确认模式：</p>
<ol>
<li><code>manual</code>：<strong>手动</strong><code>ACK</code>，在业务代码运行完毕之后调用<code>API</code>发送<code>ACK</code>，自己根据业务需求，判断消费者什么时候返回<code>ack</code>。</li>
<li><code>auto</code>：<strong>自动</strong><code>ACK</code>，由<code>Spring</code>检测<code>Listener</code>代码是否出现异常，若正常返回<code>ack</code>，若出现异常则抛出异常返回<code>nack</code>。该模式类似事务机制。</li>
<li><code>none</code>：<strong>关闭</strong><code>ack</code>，<code>MQ</code>假定消费者获取消息后会成功处理，因此消息投递后立即被删除，这种模式无法保证消息的可靠性。</li>
</ol>
<p>通常使用的消费者确认消息的机制为：<code>auto</code>模式。</p>
<h5 id="20-2-3-1-阅后即焚机制之none模式"><a href="#20-2-3-1-阅后即焚机制之none模式" class="headerlink" title="20.2.3.1 阅后即焚机制之none模式"></a>20.2.3.1 阅后即焚机制之<code>none</code>模式</h5><p>在消费者<code>consumer</code>的配置文件<code>application.yaml</code>中即可配置消费者消费返回<code>ack</code>的模式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none/auto/manual</span></span><br></pre></td></tr></table></figure>

<p>在<code>Consumer</code>模块下中的<code>CommonConfig</code>配置类声明<code>consumer.exchange</code>交换机、<code>consumer.queue</code>队列以及绑定该交换机跟队列，<code>Routing Key</code>设置为：<code>consumer.confirm</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;consumer.exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;consumer.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDirectExchangeAndDirectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue()).to(directExchange()).with(<span class="string">&quot;consumer.confirm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者监听该消息进行消费：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.mq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;consumer.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者接收到 consumer.queue 的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Consumer Queue!&quot;</span>;</span><br><span class="line">    <span class="comment">//这里的 UUID.randomUUID().toString() 的意思是定义唯一全局 ID</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">//添加回调函数</span></span><br><span class="line">    correlationData.getFuture().addCallback(result -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息从发送者到交换机的过程成功，ID:&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送者到交换机的过程消息丢失，消息发送到路由器失败, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>, correlationData.getId(), result.getReason());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, throwable -&gt; &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息从发送者到交换机的过程中发生异常, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>, correlationData.getId(), throwable.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody(message.getBytes(StandardCharsets.UTF_8)).setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;consumer.exchange&quot;</span>, <span class="string">&quot;consumer.confirm&quot;</span>, msg, correlationData);</span><br><span class="line">    <span class="comment">//等待 ACK 回执</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在模拟下<code>none</code>模式，在消费者还没处理消费就抛出异常，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.mq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;consumer.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者接收到 consumer.queue 的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时先运行消费者模块，然后发送者发送消息：可以看到虽然抛出了异常但是队列中的消息依然被删除了，这是因为我们设置了<code>none</code>模式，所以消息从队列被投递出去之后，消息队列就立马将该消息从队列中删除了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/6f423671e92e4d3ba6c57e778c741970.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2050d7aa264f40bc9f66956cf5461f88.png" alt="img"></p>
<h5 id="20-2-3-2-阅后即焚机制之auto模式"><a href="#20-2-3-2-阅后即焚机制之auto模式" class="headerlink" title="20.2.3.2 阅后即焚机制之auto模式"></a>20.2.3.2 阅后即焚机制之<code>auto</code>模式</h5><p>将上述配置文件中的<code>spring.rabbitmq.listener.simple.acknowledge-mode</code>设置为<code>auto</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none/auto/manual</span></span><br></pre></td></tr></table></figure>

<p>然后在异常处打断点，观察<code>RabbitMQ Web</code>页面的效果：可以看到因为出现异常，所以消费者返回了<code>nack</code>给消息队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e32f5ef7aada4cff852ccbd2345ba44c.png" alt="img"></p>
<p>继续执行，因为出现了异常，所以消息队列中的消息没有被删除，而是又一次等待直到被正常消费：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8af1e09bc01a41fd93d373c3ce8b5842.png" alt="img"></p>
<h5 id="20-2-3-3-消费失败重传机制"><a href="#20-2-3-3-消费失败重传机制" class="headerlink" title="20.2.3.3 消费失败重传机制"></a>20.2.3.3 消费失败重传机制</h5><p>在上述<code>auto</code>模式的测试时【不使用<code>debug</code>模式】，不知道有无有人发现，当消费者出现异常后，消息会不断<code>requeue</code>（重入队）到队列，再重新发送给消费者，然后再次异常，再次<code>requeue</code>，无限循环，导致<code>mq</code>的消息处理飙升，带来不必要的压力，你完全可以在<code>IDEA</code>控制栏中看到这一情况，一直不断不断地报错：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e220a3a42bbd46dca7e14e77c7efb20f.png" alt="img"></p>
<p>这该如何解决呢？这就涉及到消费失败重试机制了。</p>
<p><strong>消息本地重试：</strong></p>
<p>我们可以利用<code>Spring</code>的<code>retry</code>机制，在消费者出现异常时利用本地重试，而不是无限制的<code>requeue</code>到<code>mq</code>队列。然后会发送<code>ACK</code>确认消息给<code>MQ</code>，<code>MQ</code>会将该消息删除。</p>
<p>修改配置文件即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>

<p>重启<code>consumer</code>服务，重复之前的测试。可以发现：</p>
<ul>
<li>在重试<code>3</code>次后【按照上面设置地<code>max-attempts</code>来】，<code>SpringAMQP</code>会抛出异常<code>AmqpRejectAndDontRequeueException</code>，说明本地重试触发了</li>
<li>查看<code>RabbitMQ</code>控制台，发现消息被删除了，说明最后<code>SpringAMQP</code>返回的是<code>ack</code>，<code>mq</code>删除了消息</li>
</ul>
<p><strong>消息本地重试结论：达到最大重试次数后，消息会被丢弃，由Spring内部机制决定的。</strong></p>
<ul>
<li>开启本地重试时，消息处理过程中抛出异常，不会<code>requeue</code>到队列，而是在消费者本地重试</li>
<li>重试达到最大次数后，<code>Spring</code>会返回<code>ack</code>，消息会被丢弃</li>
</ul>
<p>当重试达到最大次数之后还是失败后会让实现了<code>MessageRecovery</code>的实现类来处理，实现<code>MessageRecovery</code>接口有三种方式：</p>
<ul>
<li><p><strong><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</strong></p>
</li>
<li><p><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队</p>
</li>
<li><p><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
<p>我们来尝试将重试之后的操作改为第三种，将消息投递到指定的交换机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">messageRecoverer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.exchange&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4b036138f1b946c5a388996e8ddafc8b.png" alt="img"></p>
<p><strong>总结：</strong></p>
<ul>
<li>如何确保消息在消费者这里的可靠性？<ol>
<li>开启阅后即焚机制，模式有<code>manual/auto/none</code>，手动、自动、关闭，将其设置为自动以后消费者会向消息队列发送<code>uack</code>然后一直重试</li>
<li>消息重试机制，默认为<code>RejectAndDontRequeueRecoverer</code>就是当最大的重试次数耗尽后，会发送<code>ACK</code>给消息队列，然后消息队列会将该消息删除，也可以编写<code>Bean ---&gt; MessageRecover</code>覆盖<code>RejectAndDontRequeueRecoverer</code>，可以使用：<code>ImmediateRequeueMessageRecoverer</code>或者<code>RepublishMessageRecoverer</code>，分别表示返回重试最大次数后<code>nack</code>重新入队、重试最大次数后将消息发送给指定队列。</li>
</ol>
</li>
</ul>
<h4 id="20-2-4-消息可靠性总结"><a href="#20-2-4-消息可靠性总结" class="headerlink" title="20.2.4 消息可靠性总结"></a>20.2.4 消息可靠性总结</h4><ol>
<li><p>发送过程这里：使用<strong>发送者确认机制</strong></p>
<ul>
<li><p>消息从发送者到交换机：<code>publisher-confirm</code></p>
<ol>
<li><p>会使用发送者确认机制，从生产者到交换机，若丢失返回<code>publisher-confirm-nack</code></p>
</li>
<li><p>如果没有丢失则消息队列【交换机】发送<code>publisher-confirm-ack</code></p>
<ul>
<li><p>如果在配置文件中设置的是<code>publisher-confrim:simple</code>则表示消息从发送方到交换机开始发送后一直等待交换机即消息队列返回结果，直到超时才肯罢休，可能造成代码阻塞</p>
</li>
<li><p>如果在配置文件中设置的是<code>publisher-confirm:correlated</code>则表示异步嗲用，即消息从发送方到交换机开始发送后，发发送者就可以自己干自己的事情去了，不用等待返回结果，当交换机接收到或者没接收到都会去调用<code>ConfirmCallback</code>回调函数</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>消息从交换机到队列：<code>publisher-return</code></p>
<ul>
<li>设置<code>spring.rabbitmq.publisher-returns:true</code>表示开启<code>publisher-return</code>功能，不开启则无法保证消息从交换机到队列的可靠性，然后需要进一步设置该功能开启后如果数据真的在交换机到队列这一过程丢失该怎么办，有两种选择：<code>true or false</code>，如果为<code>true</code>，则会调用<code>RabbitTemplate</code>在创建后设置的回调函数即<code>rabbitTemplate.setReturnCallback</code>。如果为<code>false</code>，则消息队列会直接将该消息丢弃。</li>
</ul>
</li>
</ul>
</li>
<li><p>到了消息队列这里：使用<strong>持久化</strong></p>
<ul>
<li>默认<code>SpringAMQP</code>创建的交换机、队列、消息都是持久化的，其中消息可以通过设置<code>MessageBuidler..setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)</code>来设置消息是否持久化。</li>
</ul>
</li>
<li><p>到了消费者这里：使用<strong>阅后即焚机制+消息重试机制</strong></p>
<ol>
<li><p>需手动开启阅后即焚机制：<code>spring.rabbitmq.listener.simple.acknowledge-mode: none/auto/maunal</code></p>
<ul>
<li>如果为<code>none</code>，当消费者消费时出现异常，照样会返回<code>ack</code>，然后消息队列丢弃该消息</li>
<li>如果为<code>auto</code>，则会一直尝试重新接收该消息，很消耗消息队列资源，所以需要开启消息重试机制</li>
</ul>
</li>
<li><p>需要手动开启<strong>重试机制</strong>：</p>
<p>重试机制需要在配置文件中<code>application.yml</code>中配置，一般在达到最大重试次数就会触发处理消息处理器：有三种消息处理器模式可选，通过定义<code>Bean ---&gt; MessageConver</code>即可覆盖，分别是：</p>
<ol>
<li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，不再接收该消息，消息被消息队列删除</li>
<li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，消费者返回<code>UACK</code>给消息队列，消息队列将消息再次入队</li>
<li><code>RepublishMessageRecoverer</code>：重试耗尽后，将消息返还给跟指定的交换机绑定的队列</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kk.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机到队列的过程消息丢失，发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;，消息&#123;&#125;&quot;</span>, replyCode, replyText, exchange, routingKey, message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Consumer Queue!&quot;</span>;</span><br><span class="line">    <span class="comment">//这里的 UUID.randomUUID().toString() 的意思是定义唯一全局 ID</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">//添加回调函数</span></span><br><span class="line">    correlationData.getFuture().addCallback(result -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息从发送者到交换机的过程成功，ID:&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送者到交换机的过程消息丢失，消息发送到路由器失败, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>, correlationData.getId(), result.getReason());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, throwable -&gt; &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息从发送者到交换机的过程中发生异常, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>, correlationData.getId(), throwable.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody(message.getBytes(StandardCharsets.UTF_8)).setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;consumer.exchange&quot;</span>, <span class="string">&quot;consumer.confirm&quot;</span>, msg, correlationData);</span><br><span class="line">    <span class="comment">//等待 ACK 回执</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">      <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none/auto/manual</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>

<p>到这里，我们就解决了<code>MQ</code>的第一个问题：消息可靠性问题。接下来我们将处理：延迟消息问题。</p>
<h3 id="20-3-死信队列和延迟队列"><a href="#20-3-死信队列和延迟队列" class="headerlink" title="20.3 死信队列和延迟队列"></a>20.3 死信队列和延迟队列</h3><h4 id="20-3-1-什么是死信队列？"><a href="#20-3-1-什么是死信队列？" class="headerlink" title="20.3.1 什么是死信队列？"></a>20.3.1 什么是死信队列？</h4><p>要谈死信队列首先得谈死信，那什么是死信呢？</p>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信<code>（dead letter）</code>：</p>
<ol>
<li><p>消费者使用<code>basic.reject</code>【拒绝】或<code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为<code>false</code></p>
</li>
<li><p>消息是一个过期消息，超时无人消费</p>
</li>
<li><p>要投递的队列消息满了，无法投递</p>
</li>
</ol>
<p>即<strong>消费失败、消息过期、队列满了</strong>就会造成死信，说白了就是要被删除的消息就是死信。</p>
<p>如果这个包含死信的队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>（<code>Dead Letter Exchange</code>，检查<code>DLX</code>）。所以死信交换机就是专门路由给死信队列的，而死信队列专门存放死信消息。</p>
<p>如图，一个消息被消费者拒绝了，变成了死信：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/29a7eabf9c6e4163867eedaea710a367.png" alt="img"></p>
<p>因为<code>simple.queue</code>绑定了死信交换机<code>dl.direct</code>，因此死信会投递给这个交换机：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f9654756cbf64f128d4b10d7095e0605.png" alt="img"></p>
<p>一般这个死信交换机会绑定了一个队列，则消息最终会进入这个存放死信的队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8feaabb444954576b2015b8302560da7.png" alt="img"></p>
<p>另外，队列将死信投递给死信交换机时，必须知道两个信息才能确保投递的消息能到达死信交换机，并且正确的路由到死信队列。：</p>
<ul>
<li>死信交换机的名称</li>
<li>死信交换机与死信队列绑定的<code>RoutingKey</code></li>
</ul>
<p><strong><font color="red">【吐槽：这不跟实现消息可靠性消费者那里尝试消息重试设置的策略为：<code>RepublishMessageRecoverer</code>一样么，将消息投递给指定队列】</font></strong></p>
<h4 id="20-3-2-利用死信交换机接收死信"><a href="#20-3-2-利用死信交换机接收死信" class="headerlink" title="20.3.2 利用死信交换机接收死信"></a>20.3.2 利用死信交换机接收死信</h4><p>在失败重试策略中，默认的<code>RejectAndDontRequeueRecoverer</code>会在本地重试次数耗尽后，发送<code>reject</code>给<code>RabbitMQ</code>，消息变成死信被丢弃掉。</p>
<p>能不能不丢弃掉这个死信呢？当然可以，我们可以添加一个死信交换机，然后将一个交换机和一个队列绑定在一块。这样消息变成死信后也不会丢弃，而是最终投递到死信交换机，路由到与死信交换机绑定的队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8feaabb444954576b2015b8302560da7.png" alt="img"></p>
<p>演示下，使用<code>SpringAMQP</code>定义死信交换机、死信队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明普通的 simple.queue队列，并且为其指定死信交换机：dl.direct</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明死信交换机 dl.direct</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">dlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;dl.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明存储死信的队列 dl.queue</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">dlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;dl.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将死信队列 与 死信交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">dlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(dlQueue()).to(dlExchange()).with(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-3-3-小结"><a href="#20-3-3-小结" class="headerlink" title="20.3.3 小结"></a>20.3.3 小结</h4><ul>
<li>什么样的消息会成为死信？<ul>
<li>被消费者<code>reject</code>&#x2F;<code>nack</code>的</li>
<li>消息超时未消费的</li>
<li>队列已满无法投递</li>
</ul>
</li>
<li>死信交换机的使用场景是什么？<ul>
<li>某队列只要绑定了死信交换机，死信会投递到死信交换机，没有绑的不会</li>
<li>可以利用死信交换机收集所有消费者处理失败的消息（死信），交由人工处理，进一步提高消息队列的可靠性【集中统一管理死信，很棒的<code>IDEA</code>】</li>
</ul>
</li>
</ul>
<h4 id="20-3-4-过期时间TTL"><a href="#20-3-4-过期时间TTL" class="headerlink" title="20.3.4 过期时间TTL"></a>20.3.4 过期时间<code>TTL</code></h4><p>一个队列中的某消息如果超时未消费，则会变为死信，超时分为两种情况【整体 + 局部】：</p>
<ul>
<li>消息所在的队列设置了超时时间</li>
<li>消息本身设置了超时时间</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/5042c6e643094c7ca3427638b8f3fbf5.png" alt="img"></p>
<p>可以定义一个接收超时死信的死信交换机，<code>Routing Key</code>设置为<code>ttl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;dl.ttl.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;dl.ttl.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;ttl&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 dl.ttl.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当声明一个队列时，可以给将来存储在该队列的所有消息一个<code>TTL</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;ttl.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">        .ttl(<span class="number">10000</span>) <span class="comment">// 单位为毫秒 ms，设置队列的超时时间，10秒</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.ttl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：该队列绑定的死信交换机为<code>dl.ttl.direct</code>，成为死信的消息会被投递到死信交换机绑定的队列</p>
<p>声明交换机，将上面定义的<code>ttl.queue</code>队列跟<code>ttl.direct</code>交换机绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">ttlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;ttl.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">ttlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with(<span class="string">&quot;ttl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20-3-4-1-指定队列的TTL"><a href="#20-3-4-1-指定队列的TTL" class="headerlink" title="20.3.4.1 指定队列的TTL"></a>20.3.4.1 指定队列的<code>TTL</code></h5><p>发送消息给<code>ttl.direct</code>交换机，然后到了<code>ttl.queue</code>，等待<code>10s</code>以上，然后观察死信交换机绑定的死信队列<code>dl.queue</code>，可以看到该队列会得到<code>ttl.queue</code>过期的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTTLQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, ttl queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看发送消息到<code>ttl.queue</code>的日志：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4dce1b7397404f45bf3255993d7b722f.png" alt="img"></p>
<p>查看过期的消息被投递到<code>dl.queue</code>死信队列的日志：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/1fa49614e87e48cc8b6e025f5d0b8f5a.png" alt="img"></p>
<p>同时你也可以看到时间刚好是<code>10s</code>说明过期时间<code>TTL = 10s</code>。</p>
<h5 id="20-3-4-2-指定消息的TTL"><a href="#20-3-4-2-指定消息的TTL" class="headerlink" title="20.3.4.2 指定消息的TTL"></a>20.3.4.2 指定消息的<code>TTL</code></h5><p>跟设置持久化一样，同样可以通过<code>MessageBuilder</code>创建<code>Message</code>对象的时候给该消息设置过期时间：<code>5000</code>表示<code>5s</code>，这里单位是<code>ms</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTTLMsg</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">        .withBody(<span class="string">&quot;hello, ttl message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setExpiration(<span class="string">&quot;5000&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看发送消息到<code>ttl.queue</code>的日志：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/d64887c75435403bb3ef3a9c8d2a7488.png" alt="img"></p>
<p>查看过期的消息被投递到<code>dl.queue</code>死信队列的日志：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8012e70753454ae6a16a088ce9bdf4f4.png" alt="img"></p>
<p>同时你也可以看到时间刚好是<code>5s</code>说明该消息过期时间<code>TTL = 5s</code>。</p>
<h5 id="20-3-4-3-过期时间"><a href="#20-3-4-3-过期时间" class="headerlink" title="20.3.4.3 过期时间"></a>20.3.4.3 过期时间</h5><ul>
<li><p>消息超时的两种方式是？</p>
<ul>
<li><p>给队列设置<code>TTL</code>属性，进入队列后超过<code>TTL</code>时间的消息变为死信</p>
</li>
<li><p>给消息设置<code>TTL</code>属性，队列接收到消息超过<code>TTL</code>时间后变为死信</p>
</li>
</ul>
</li>
<li><p>如何实现发送一个消息<code>20</code>秒后消费者才收到消息？</p>
<ul>
<li>给消息的目标队列指定死信交换机</li>
<li>将消费者监听的队列绑定到死信交换机</li>
<li>发送消息时给消息设置超时时间为<code>20</code>秒</li>
</ul>
</li>
</ul>
<h4 id="20-3-5-延迟队列"><a href="#20-3-5-延迟队列" class="headerlink" title="20.3.5 延迟队列"></a>20.3.5 延迟队列</h4><p>前面学习了死信队列跟<code>TTL</code>，试想下，如果<code>TTL</code>到了我们将其发送给一个死信队列，这样不就构成了延迟消费吗？！没错！这就是延迟队列<code>Delay Queue</code>模式！</p>
<p><strong>多久之后要做什么事情而且用户量很大的，都可以考虑使用延迟队列！</strong></p>
<p>延迟队列的使用场景包括：</p>
<ul>
<li>延迟发送短信</li>
<li>用户下单，如果用户在<code>15</code>分钟内未支付，则自动取消</li>
<li>预约工作会议，<code>20</code>分钟后自动通知所有参会人员</li>
</ul>
<p><strong><font color="red">而且关于延迟队列有个非常<code>NICE</code>的东西：</font></strong></p>
<p>因为延迟队列的需求非常多，所以<code>RabbitMQ</code>的官方也推出了一个插件，原生支持延迟队列效果。</p>
<p>这个插件就是<code>DelayExchange</code>插件。参考<code>RabbitMQ</code>的插件列表页面：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ac0ebc344064441e9df0165ac0aede86.png" alt="img"></p>
<p>使用方式可以参考官网地址：<a target="_blank" rel="noopener" href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p>
<h4 id="20-3-6-安装DelayExchange插件实现延迟队列效果"><a href="#20-3-6-安装DelayExchange插件实现延迟队列效果" class="headerlink" title="20.3.6 安装DelayExchange插件实现延迟队列效果"></a>20.3.6 安装<code>DelayExchange</code>插件实现延迟队列效果</h4><p>去对应的<code>GitHub</code>页面下载<code>3.8.9</code>版本的插件，地址为<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/3.8.9%E8%BF%99%E4%B8%AA%E5%AF%B9%E5%BA%94%60RabbitMQ%60%E7%9A%84%603.8.5%60%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E3%80%82">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/3.8.9这个对应`RabbitMQ`的`3.8.5`以上版本。</a></p>
<p>因为我们是基于<code>Docker</code>安装，所以需要先查看<code>RabbitMQ</code>的插件目录对应的数据卷，使用如下命令可以查看数据卷，然后将已经下载好的插件，上传到<code>Linux</code>中即可。</p>
<p>进入到<code>rabbitmq</code>安装插件即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it rabbitmq bash</span><br></pre></td></tr></table></figure>

<p>因为这个插件我上传到的是<code>/usr/local/src/</code>目录中，所以先移动到<code>/plugins</code>中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv rabbitmq_delayed_message_exchange-3.8.9-0199d11c.ez /plugins</span><br></pre></td></tr></table></figure>

<p>然后开启延迟队列插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/aa73c5dd34774761b8ad7c0f523d2a60.png" alt="img"></p>
<h4 id="20-3-7-DelayExchange的原理"><a href="#20-3-7-DelayExchange的原理" class="headerlink" title="20.3.7 DelayExchange的原理"></a>20.3.7 <code>DelayExchange</code>的原理</h4><p><code>DelayExchange</code>需要将一个交换机声明为<code>delayed</code>类型。当我们发送消息到<code>delayExchange</code>时，流程如下：</p>
<ul>
<li>接收消息</li>
<li>判断消息是否具备<code>x-delay</code>属性</li>
<li>如果有<code>x-delay</code>属性，说明是延迟消息，持久化到硬盘，读取<code>x-delay</code>值，作为延迟时间</li>
<li>返回<code>routing not found</code>结果给消息发送者</li>
<li><code>x-delay</code>时间到期后，重新投递消息到指定队列</li>
</ul>
<p>本质上还是：消息&#x2F;队列设置<code>TTL</code>，到点就投送到指定死信队列。</p>
<h4 id="20-3-8-延迟发送消息的具体操作"><a href="#20-3-8-延迟发送消息的具体操作" class="headerlink" title="20.3.8 延迟发送消息的具体操作"></a>20.3.8 延迟发送消息的具体操作</h4><p>插件让延迟队列变得异常简单：声明一个交换机，交换机的类型可以是任意类型，只需要设定<code>delayed</code>属性为<code>true</code>即可，然后声明队列与其绑定即可。</p>
<ol>
<li><p>声明<code>DelayExchange</code>交换机</p>
<ol>
<li><p>基于注解方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(value = @Queue(value = &quot;delay.queue&quot;, durable = &quot;true&quot;), exchange = @Exchange(name = &quot;delay.direct&quot;, durable = &quot;true&quot;, delayed = &quot;true&quot;), key = &quot;delay&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayedQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">	log.info(<span class="string">&quot;接收到 delay.queue 的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于<code>@Bean</code>配置类的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;delay.direct&quot;</span>).delayed().durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>基于配置类的的声明队列方式【注解的在声明交换机的时候已经做了】：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue delayedQueue() &#123;</span><br><span class="line">    return new Queue(&quot;delay.queue&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定交换机跟队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">delayedBinding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayedExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息，因为是延迟队列需要带<code>x-delay</code>属性，本质就是声明<code>TTL</code>，要不之前我们需要<code>MessageBuilder.setExpiration(ms)</code>来做<code>TTL</code>，然后还要声明：存储的交换机、存储的队列，死信交换机、死信队列，如果是给整个存储队列设置<code>TTL</code>此时还需要在声明存储队列的时设置<code>ttl</code>。因为存储队列绑定私信交换机，所以需要用到<code>QueueBuilder.durable(&quot;存储队列名称&quot;).deadLetterExchange(&quot;死信交换机名称&quot;).build();</code></p>
<p>现在有了延迟队列的插件，直接声明交换机、队列，交换机带上<code>delayed()[true]</code>，然后发送的消息设置<code>Header x-delay</code>其实就是过期时间，然后就可以实现延迟队列的效果了，非常简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Consumer Queue!&quot;</span>;</span><br><span class="line">    <span class="comment">//这里的 UUID.randomUUID().toString() 的意思是定义唯一全局 ID</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">//添加回调函数</span></span><br><span class="line">    correlationData.getFuture().addCallback(result -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息从发送者到交换机的过程成功，ID:&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送者到交换机的过程消息丢失，消息发送到路由器失败, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>, correlationData.getId(), result.getReason());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, throwable -&gt; &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息从发送者到交换机的过程中发生异常, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>, correlationData.getId(), throwable.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody(message.getBytes(StandardCharsets.UTF_8)).setDeliveryMode(MessageDeliveryMode.PERSISTENT).setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>).build();</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, msg, correlationData);</span><br><span class="line">    log.debug(<span class="string">&quot;消息发送成功！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="20-3-9-总结"><a href="#20-3-9-总结" class="headerlink" title="20.3.9 总结"></a>20.3.9 总结</h4><ul>
<li>延迟队列插件的使用步骤包括哪些？<ul>
<li>声明一个交换机，添加<code>delayed</code>属性为<code>true</code></li>
<li>发送消息时，添加<code>x-delay</code>头，值为超时时间</li>
</ul>
</li>
</ul>
<p><strong>到这里就解决了消息延迟发送的问题，满足了特定业务上的需求，接下来就需要解决下一个问题了 —— 消息堆积问题：可能一下子有太多的请求导致可能有几百万的消息还没来得及消费，就堆积在了消息队列中，这个问题是怎么产生的呢？又该如何解决呢？</strong></p>
<h3 id="20-5-解决消息堆积问题的惰性队列"><a href="#20-5-解决消息堆积问题的惰性队列" class="headerlink" title="20.5 解决消息堆积问题的惰性队列"></a>20.5 解决消息堆积问题的惰性队列</h3><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。我们前面说过，队列满了之后再投递的消息就会变成死信，死信如果没有转到死信队列绑定的队列，可能就会被丢弃，这就是<strong>消息堆积问题</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/12f4ab0b5a194360be1903ab40b0ee58.png" alt="img"></p>
<p>这些消息不是因为没用才被丢，而是因为客观原因：生产者速度太快了，队列满了导致的，所以这些消息很可能还是有价值的，因此我们要想办法解决消息堆积问题。</p>
<ul>
<li>第一个思路：我们知道是消费者跟不上生产者的生产速度，那增加消费者，提高消费速度不就好了。</li>
<li>第二个思路：能不能想办法吧消息队列的容量扩大，这样能存放的消息就更多了。</li>
</ul>
<p>虽然两个思路都有各自的缺陷，但承认都是解决消息堆积问题的好办法！但是还有没有更好的办法呢？</p>
<p>我们知道消息堆积问题本质就是因为容量不够导致的，而且我们还知道消息队列是将消息存放在内存中的，这下我们就发现了华点，内存的容量小但是还有磁盘啊，我磁盘的容量肯定比内存大得多得多啊。所以我们就引出了第三个思路。</p>
<ul>
<li>第三个思路：对于容量满的消息队列，还要存放的消息，将其放到磁盘当中而非内存，当消费者需要消费该消息时就从磁盘中读取。磁盘很大，可以支持上百万条的消息存储。</li>
</ul>
<p>第三个思路虽然舍弃了速度和性能上的追求，但是但是！相比于无价的数据可言是值得的！！</p>
<p>而实现了第三个思路的，正是从<code>RabbitMQ</code>的<code>3.6.0</code>版本开始推出的：<code>Lazy Queues</code>的概念！即惰性队列！</p>
<p>惰性队列的特点就是我们上面提到的，我们整理一下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<h4 id="20-5-1-使用命令方式设置惰性队列"><a href="#20-5-1-使用命令方式设置惰性队列" class="headerlink" title="20.5.1 使用命令方式设置惰性队列"></a>20.5.1 使用命令方式设置惰性队列</h4><p>可以在<code>RabbitMQ</code>内部中使用命令的方式设置惰性队列，要设置一个队列为惰性队列，只需要在声明队列时，指定<code>x-queue-mode</code>属性为<code>lazy</code>即可。可以通过命令行将一个运行中的队列修改为惰性队列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li><code>rabbitmqctl</code> ：<code>RabbitMQ</code>的命令行工具</li>
<li><code>set_policy</code> ：添加一个策略</li>
<li><code>Lazy</code> ：策略名称，可以自定义</li>
<li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li>
<li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li>
<li><code>--apply-to queues  </code>：策略的作用对象，是所有的队列</li>
</ul>
<h4 id="20-5-2-基于注解方式设置惰性队列"><a href="#20-5-2-基于注解方式设置惰性队列" class="headerlink" title="20.5.2 基于注解方式设置惰性队列"></a>20.5.2 基于注解方式设置惰性队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;lazy.queue&quot;, durable = &quot;true&quot;, arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue 的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-5-3-基于Bean方式设置惰性队列"><a href="#20-5-3-基于Bean方式设置惰性队列" class="headerlink" title="20.5.3 基于Bean方式设置惰性队列"></a>20.5.3 基于<code>Bean</code>方式设置惰性队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;lazy.queue&quot;</span>).lazy().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到基于配置类的方式设置惰性队列是最简单的。</p>
<h4 id="20-5-4-惰性队列总结"><a href="#20-5-4-惰性队列总结" class="headerlink" title="20.5.4 惰性队列总结"></a>20.5.4 惰性队列总结</h4><ul>
<li>消息堆积问题的解决方案？<ul>
<li>第一种思路：交换机再绑定多个消费者或者给消费者开线程池，提高消费速度</li>
<li>第二种思路：扩大消息队列的容量，本质就是扩大内存【不现实】</li>
<li>第三种思路：使用惰性队列，将消息存储到硬盘中</li>
</ul>
</li>
<li>惰性队列的优点有哪些？<ul>
<li>基于硬盘存储消息，消息存储上限高</li>
<li>没有间歇性的<code>page-out</code>直接写磁盘，而不是先写内存再到磁盘，性能比较高</li>
</ul>
</li>
<li>惰性队列的缺点有哪些？<ul>
<li>速度肯定是没有内存那么快的，受限于硬盘<code>I/O</code></li>
<li>基于磁盘存储所以消息时效性比较低</li>
</ul>
</li>
</ul>
<p>到这里就就觉了消息可靠性问题、消息延迟推送问题、消息堆积问题，只剩下了最后一个问题即高可用的问题。</p>
<h3 id="20-6-MQ集群"><a href="#20-6-MQ集群" class="headerlink" title="20.6 MQ集群"></a>20.6 <code>MQ</code>集群</h3><p>一想到高并发高可用，就想到做集群，没错这样的思路非常正确，<code>MQ</code>也可以做集群，因为<code>RabbitMQ</code>是基于<code>Erlang</code>这门语言编写的而<code>Erlang</code>这门语言拥有跟原生<code>Socket</code>一样的延迟，效率非常高，而且进程间上下文切换效率远高于<code>C</code>语言，天然支持集群模式。<code>RabbitMQ</code>的集群有两种模式：</p>
<ul>
<li><strong>普通集群：</strong>是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</li>
<li><strong>镜像集群：</strong>是一种主从集群，再普通集群的基础上，添加了主从备份的功能，提高了集群的数据可用性。</li>
</ul>
<p>镜像集群虽然支持主从备份，但是从主从同步不是强一致的，某些情况下可能具有丢失数据的风险。因此<code>RabbitMQ</code>在<code>3,8</code>版本之后，推出了全新的功能：<strong>仲裁队列</strong>。用于替代镜像集群，底层采用<code>Raft</code>协议确保主从节点的数据一致性。</p>
<h4 id="20-6-1-普通集群"><a href="#20-6-1-普通集群" class="headerlink" title="20.6.1 普通集群"></a>20.6.1 普通集群</h4><p>普通集群，也叫标准集群<code>classic cluster</code>，具备以下特征：</p>
<ol>
<li><p>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</p>
</li>
<li><p>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回。</p>
</li>
<li><p>队列所在节点宕机，队列中的消息就会丢失。</p>
<p><strong><font color="red">比如有两个消息队列<code>MQ1、MQ2</code>，如果你的消息在<code>MQ1</code>但是你连接的交换机绑定的队列是<code>MQ2</code>，此时<code>MQ2</code>就会去<code>MQ1</code>队列拉取消息然后返回消息。如果<code>MQ1</code>宕机消息就会丢失。</font></strong></p>
</li>
</ol>
<p>普通集群的结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/281966932a2645209e4324951c0d5e17.png" alt="img"></p>
<h4 id="20-6-2-安装普通集群"><a href="#20-6-2-安装普通集群" class="headerlink" title="20.6.2 安装普通集群"></a>20.6.2 安装普通集群</h4><p>计划部署如下：</p>
<table>
<thead>
<tr>
<th>主机名</th>
<th><code>WEB</code>控制台端口</th>
<th><code>AMQP</code>通信端口</th>
</tr>
</thead>
<tbody><tr>
<td><code>mq1</code></td>
<td><code>8081 ---&gt; 15672</code></td>
<td><code>8071 ---&gt; 5672</code></td>
</tr>
<tr>
<td><code>mq2</code></td>
<td><code>8082 ---&gt; 15672</code></td>
<td><code>8072 ---&gt; 5672</code></td>
</tr>
<tr>
<td><code>mq3</code></td>
<td><code>8083 ---&gt; 15672</code></td>
<td><code>8073  ---&gt; 5672</code></td>
</tr>
</tbody></table>
<p><code>RabbitMQ</code>底层依赖于<code>Erlang</code>，而<code>Erlang</code>虚拟机就是一个面向分布式的语言，默认就支持集群模式。</p>
<p><strong><font color="red">集群模式中的每个<code>RabbitMQ</code>节点使用<code>cookie</code>来确定它们是否被允许相互通信。</font></strong></p>
<p>这里的<code>cookie</code>是什么意思呢？其实啊，要使两个<code>MQ</code>节点能够通信，它们必须具有相同的共享秘密，称为**<code>Erlang cookie</code>**。<code>cookie</code>只是一串最多<code>255</code>个字符的字母数字字符。</p>
<p>因为在同一个集群中的节点肯定是需要相互通信的，也正因此它们就需要相同的<code>Cookie</code>，有了它才可以通信。</p>
<p>可以通过获取某个节点的<code>cookie</code>值作为整个集群的<code>cookie</code>。执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it rabbitmq cat /var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure>

<p>可以看到cookie值如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPSROPMOTDLBSLLQEPBO</span><br></pre></td></tr></table></figure>

<p>接下来，停止并删除当前的所有<code>RabbitMQ</code>容器，搭建集群。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f rabbitmq</span><br></pre></td></tr></table></figure>

<p>在<code>/tmp</code>目录新建一个配置文件<code>rabbitmq.conf</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line"><span class="built_in">touch</span> rabbitmq.conf</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loopback_users.<span class="attribute">guest</span> = <span class="literal">false</span></span><br><span class="line">listeners.tcp.default = <span class="number">5672</span></span><br><span class="line">cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config</span><br><span class="line">cluster_formation.classic_config.nodes.<span class="number">1</span> = rabbit<span class="variable">@mq1</span></span><br><span class="line">cluster_formation.classic_config.nodes.<span class="number">2</span> = rabbit<span class="variable">@mq2</span></span><br><span class="line">cluster_formation.classic_config.nodes.<span class="number">3</span> = rabbit<span class="variable">@mq3</span></span><br></pre></td></tr></table></figure>

<p>再创建一个文件，记录cookie</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建cookie文件</span></span><br><span class="line"><span class="built_in">touch</span> .erlang.cookie</span><br><span class="line"><span class="comment"># 写入cookie</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;UPSROPMOTDLBSLLQEPBO&quot;</span> &gt; .erlang.cookie</span><br><span class="line"><span class="comment"># 修改cookie文件的权限</span></span><br><span class="line"><span class="built_in">chmod</span> 600 .erlang.cookie</span><br></pre></td></tr></table></figure>

<p>准备三个目录，<code>mq1、mq2、mq3</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> mq1 mq2 mq3</span><br></pre></td></tr></table></figure>

<p>然后拷贝<code>rabbitmq.conf、cookie</code>文件到<code>mq1、mq2、mq3</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 拷贝</span></span><br><span class="line"><span class="built_in">cp</span> rabbitmq.conf mq1</span><br><span class="line"><span class="built_in">cp</span> rabbitmq.conf mq2</span><br><span class="line"><span class="built_in">cp</span> rabbitmq.conf mq3</span><br><span class="line"><span class="built_in">cp</span> .erlang.cookie mq1</span><br><span class="line"><span class="built_in">cp</span> .erlang.cookie mq2</span><br><span class="line"><span class="built_in">cp</span> .erlang.cookie mq3</span><br></pre></td></tr></table></figure>

<p>启动集群，需要为<code>RabbitMQ</code>创建一个网络【因为是集群】，否则集群不可用，创建一个网络的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create mq-net</span><br></pre></td></tr></table></figure>

<p>创建节点容器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net mq-net \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq1/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq1/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=admin \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line">--name mq1 \</span><br><span class="line">--hostname mq1 \</span><br><span class="line">-p 8071:5672 \</span><br><span class="line">-p 8081:15672 \</span><br><span class="line">rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net mq-net \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq2/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq2/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=admin \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line">--name mq2 \</span><br><span class="line">--hostname mq2 \</span><br><span class="line">-p 8072:5672 \</span><br><span class="line">-p 8082:15672 \</span><br><span class="line">rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net mq-net \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq3/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq3/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=admin \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line">--name mq3 \</span><br><span class="line">--hostname mq3 \</span><br><span class="line">-p 8073:5672 \</span><br><span class="line">-p 8083:15672 \</span><br><span class="line">rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>

<p>我这里<code>CentOS</code>的做的网络是<code>NAT</code>地址转换，如果你也一样的话记得做一个端口映射：<code>8081 8082 8083</code></p>
<p>可以登录<code>RabbitMQ</code>的<code>Web</code>控制页面，可以看到集群中的节点信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/dc4abce2a7cc4a1ea20e2524df2f61ee.png" alt="img"></p>
<p>在<code>mq1</code>节点上添加一个队列，然后观察<code>mq2 mq3</code>控制台：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8bac5a00e8ed46cba830e9cc2fdd79b2.png" alt="img"></p>
<p>可以看到在<code>mq2 mq3</code>这两个控制台都可以看到<code>mq1</code>控制台创建的队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/aff03f14693c4ed0af37f1b1f204a1d7.png" alt="img"></p>
<p>还可以进行数据共享的测试：</p>
<p>点击刚刚在<code>mq1</code>创建的<code>simple.queue</code>队列，进入管理页面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/88b6389d2a3a49fbbe19b82312ae39c8.png" alt="img"></p>
<p>给这个<code>simple.queue</code>队列发送一个消息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/7bf71f1af80e4881b693d199f7c6e0d2.png" alt="img"></p>
<p>结果在<code>mq2</code>、<code>mq3</code>上都能看到这条消息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3e480f411c4a455b824693c70cceb0e7.png" alt="img"></p>
<p>如果此时让<code>mq1</code>宕机，此时通过<code>mq2 mq3</code>是访问不到<code>simple.queue</code>的，因为在普通集群中，<code>mq2 mq3</code>会去拉取<code>mq1</code>中的<code>simple.queue</code>队列。但此时<code>mq1</code>已经宕机，所以就拉取不到了，自然也就无法访问了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4d88abd34c664668b0d91859f1210dc8.png" alt="img"></p>
<p>这也恰恰说明了不同节点上的队列是不会将本节点的消息拷贝给其它节点的。会造成业务数据上的损失，若宕机，可用性丢失。</p>
<h4 id="20-6-3-镜像集群"><a href="#20-6-3-镜像集群" class="headerlink" title="20.6.3 镜像集群"></a>20.6.3 镜像集群</h4><p>在刚刚的普通集群中，一旦创建队列的主机宕机，队列就会不可用。不具备高可用能力。如果要解决这个问题，可以使用镜像集群，镜像集群本质是主从模式，具备下面的特征：</p>
<ol>
<li>交换机、队列、队列中的消息会在各个<code>mq</code>的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点。</li>
<li>所有操作都是主节点完成，然后同步给镜像节点。用户发送给队列的一切请求，例如发送消息、消息回执默认都会在主节点完成，如果是从节点接收到请求，也会路由到主节点去完成。<strong>镜像节点仅仅起到备份数据作用</strong>。当主节点接收到消费者的<code>ACK</code>时，所有镜像都会删除节点中的数据。</li>
<li>主宕机后，镜像节点会替代成新的主。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/6db7c93810324f5d9a3fdec88d9e03a3.png" alt="img"></p>
<p>镜像模式的配置有3种模式：</p>
<table>
<thead>
<tr>
<th align="left"><code>ha-mode</code></th>
<th align="left"><code>ha-params</code></th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">准确模式<code>exactly</code></td>
<td align="left">队列的副本量<code>count</code></td>
<td align="left">集群中队列副本（主服务器和镜像服务器之和）的数量。<code>count</code>如果为<code>1</code>意味着单个副本：即队列主节点。<code>count</code>值为<code>2</code>表示<code>2</code>个副本：<code>1</code>个队列主和<code>1</code>个队列镜像。换句话说：<code>count = 镜像数量 + 1</code>。如果群集中的节点数少于<code>count</code>，则该队列将镜像到所有节点。如果有集群总数大于<code>count+1</code>，并且包含镜像的节点出现故障，则将在另一个节点上创建一个新的镜像。</td>
</tr>
<tr>
<td align="left"><code>all</code></td>
<td align="left"><code>(none)</code></td>
<td align="left">队列在群集中的所有节点之间进行镜像。队列将镜像到任何新加入的节点。镜像到所有节点将对所有群集节点施加额外的压力，包括网络<code>I / O</code>，磁盘<code>I / O</code>和磁盘空间使用情况。推荐使用<code>exactly</code>，设置副本数为<code>（N / 2 +1）</code>。</td>
</tr>
<tr>
<td align="left"><code>nodes</code></td>
<td align="left"><em><code>node names</code></em></td>
<td align="left">指定队列创建到哪些节点，如果指定的节点全部不存在，则会出现异常。如果指定的节点在集群中存在，但是暂时不可用，会创建节点到当前客户端连接到的节点。</td>
</tr>
</tbody></table>
<p>这里我们以<code>rabbitmqctl</code>命令作为案例来讲解配置语法。</p>
<p><strong><code>exactly</code>模式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-two &quot;^two\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rabbitmqctl set_policy</code>：固定写法</li>
<li><code>ha-two</code>：策略名称，自定义</li>
<li><code>&quot;^two\.&quot;</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>two.</code>开头的队列名称</li>
<li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#39;</code>: 策略内容<ul>
<li><code>&quot;ha-mode&quot;:&quot;exactly&quot;</code>：策略模式，此处是<code>exactly</code>模式，指定副本数量</li>
<li><code>&quot;ha-params&quot;:2</code>：策略参数，这里是<code>2</code>，就是副本数量为<code>2</code>，<code>1</code>主<code>1</code>镜像</li>
<li><code>&quot;ha-sync-mode&quot;:&quot;automatic&quot;</code>：同步策略，默认是<code>manual</code>【手动的】，即新加入的镜像节点不会同步旧的消息。如果设置为<code>automatic</code>【自动的】，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</li>
</ul>
</li>
</ul>
<p><strong><code>all</code>模式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all &quot;^all\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ha-all</code>：策略名称，自定义</li>
<li><code>&quot;^all\.&quot;</code>：匹配所有以<code>all.</code>开头的队列名</li>
<li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#39;</code>：策略内容<ul>
<li><code>&quot;ha-mode&quot;:&quot;all&quot;</code>：策略模式，此处是<code>all</code>模式，即所有节点都会称为镜像节点</li>
</ul>
</li>
</ul>
<p><strong><code>nodes</code>模式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-nodes &quot;^nodes\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rabbitmqctl set_policy</code>：固定写法</li>
<li><code>ha-nodes</code>：策略名称，自定义</li>
<li><code>&quot;^nodes\.&quot;</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>nodes.</code>开头的队列名称</li>
<li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&#39;</code>: 策略内容<ul>
<li><code>&quot;ha-mode&quot;:&quot;nodes&quot;</code>：策略模式，此处是<code>nodes</code>模式</li>
<li><code>&quot;ha-params&quot;:[&quot;rabbit@mq1&quot;, &quot;rabbit@mq2&quot;]</code>：策略参数，这里指定副本所在节点名称</li>
</ul>
</li>
</ul>
<h4 id="20-6-4-安装镜像集群"><a href="#20-6-4-安装镜像集群" class="headerlink" title="20.6.4 安装镜像集群"></a>20.6.4 安装镜像集群</h4><p>需求：使用<code>exactly</code>模式的镜像，因为集群节点数量为<code>3</code>，因此镜像数量就设置为<code>2</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq1 rabbitmqctl set_policy ha-two &quot;^two\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>在<code>mq1</code>节点中创建一个新的队列，然后查看<code>mq1 mq2</code>控制台：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/54daa85685734d019af52adfa544e521.png" alt="img"></p>
<p>可以看到无论是在<code>mq1</code>还是<code>mq2</code>都可以看到队列，到这里为止，跟普通集群没什么差别，看起来差别在于<code>Features</code>特征上有个<code>ha-two</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4fb2e16af079493d9472ee787d023e36.png" alt="img"></p>
<p>同样的，跟普通集群一样，也可以进行数据共享，关键是看某个节点宕机的时候，比如<code>mq1</code>宕机，但此时仍然可以消费<code>two.queue</code>中的消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mq1</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/5510e1b2290940c5be35e98c9337ba16.png" alt="img"></p>
<p>查看<code>two.queue</code>队列状态，可以发现依然是健康的，因为主节点从<code>rabbit@mq1</code>切换到了<code>rabbit@mq2</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/6d09c2426e3745ca961978db41575375.png" alt="img"></p>
<h4 id="20-6-5-仲裁队列"><a href="#20-6-5-仲裁队列" class="headerlink" title="20.6.5 仲裁队列"></a>20.6.5 仲裁队列</h4><p>仲裁队列是<code>RabbitMQ3.8</code>版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步，之前的镜像集群主从之间的数据备份存在一定的间隔性所以不是强一致性的。</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于<code>Raft</code>协议，强一致</li>
</ul>
<p>简单地说就是仲裁队列是为了强一致性新推出的，而且操作简单。</p>
<h4 id="20-6-6-添加仲裁队列"><a href="#20-6-6-添加仲裁队列" class="headerlink" title="20.6.6 添加仲裁队列"></a>20.6.6 添加仲裁队列</h4><p>在任意控制台添加一个队列，一定要选择队列类型为<code>Quorum</code>类型：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/10c2a20cf74049d292998c2d4110ca2d.png" alt="img"></p>
<p>在任意控制台查看队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/5a1dc2943c014fe78d02ceac9cc49fa0.png" alt="img"></p>
<p>可以看到，仲裁队列的 + 2字样。代表这个队列有2个镜像节点。</p>
<p>若要测试，可以参照之前的普通集群、镜像集群做测试，查看数据共享以及宕机后队列是否可用。</p>
<h4 id="20-6-7-集群扩容"><a href="#20-6-7-集群扩容" class="headerlink" title="20.6.7 集群扩容"></a>20.6.7 集群扩容</h4><p>因为仲裁队列默认的镜像数为<code>5</code>。如果你的集群有<code>7</code>个节点，那么镜像数肯定是<code>5</code>，而我们集群只有<code>3</code>个节点，因此镜像数量就是<code>3</code>。为了达到这个效果，我们需要先做集群扩容然后进行仲裁队列副本扩容即可，先做集群节点扩容：</p>
<ol>
<li><p>开启一个新的<code>MQ</code>容器，不用指定配置文件，等等可以使用<code>rabbitmqctl</code>将其拉入集群，但是前提是得在同一个网络，所以这里需要使用<code>--net</code>，除此之外还要配置下<code>cookie</code>，否则无法跟家族成员进行通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net mq-net \</span><br><span class="line">-v $&#123;PWD&#125;/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=admin \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line">--name mq4 \</span><br><span class="line">--hostname mq4 \</span><br><span class="line">-p 8074:5672 \</span><br><span class="line">-p 8084:15672 \</span><br><span class="line">rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>mq4</code>控制台</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq4 bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止<code>mq4</code>进程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置RabbitMQ中的数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl reset</span><br></pre></td></tr></table></figure>

</li>
<li><p>加入<code>mq</code>集群：【记得之前要是进行了让<code>mq1</code>宕机的测试，需要先启动<code>mq1</code>，否则会一直启动报错】</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl join_cluster rabbit@mq1</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动<code>mq4</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察<code>mq1 web</code>控制台：可以看到扩容成功</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/065a6985336342e897a28567fa63c196.png" alt="img"></p>
</li>
</ol>
<h4 id="20-6-8-仲裁队列副本扩容"><a href="#20-6-8-仲裁队列副本扩容" class="headerlink" title="20.6.8 仲裁队列副本扩容"></a>20.6.8 仲裁队列副本扩容</h4><p>我们先查看下<code>quorum.queue</code>这个队列目前的副本情况，进入<code>mq1</code>容器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mq1 bash</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-queues quorum_status <span class="string">&quot;quorum.queue&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果，可以看到只有<code>mq1 mq2 mq3</code>，没有刚刚新加入的节点<code>mq4</code>作为镜像副本：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/83361db1250346fcbaf969d69e6a8fb3.png" alt="img"></p>
<p>现在，我们让<code>mq4</code>也加入进来：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-queues add_member <span class="string">&quot;quorum.queue&quot;</span> <span class="string">&quot;rabbit@mq4&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/22ea761cb255440da56b87892921d961.png" alt="img"></p>
<p>再次查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-queues quorum_status <span class="string">&quot;quorum.queue&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/0130618fdd6f40c197f0b9dacb6e5e40.png" alt="img"></p>
<p>查看控制台，发现<code>quorum.queue</code>的镜像数量也从原来的<code>+2</code>变成了<code> +3</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f2e5290383a449a7936a426479853eaa.png" alt="img"></p>
<p>在<code>Java</code>中也同样可以创建仲裁队列，使用<code>quorum()</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(<span class="string">&quot;quorum.queue&quot;</span>) <span class="comment">// 持久化</span></span><br><span class="line">        .quorum() <span class="comment">// 仲裁队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要连接时，在配置文件进行如下配置即可</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span><span class="string">:8071,</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span><span class="string">:8072,</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span><span class="string">:8073</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<p>到这里，整个<code>MQ</code>集群就学习完毕啦~:smiley:</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Krolliaa</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/12/RabbitMQStudy/">http://example.com/2022/08/12/RabbitMQStudy/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Krolliaa</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></div><div class="post_share"><div class="social-share" data-image="/img/index_img/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/12/SpringStudyStudy/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Study</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/12/NginxStudy/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Nginx Study</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/header.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Krolliaa</div><div class="author-info__description">俱往矣，数风流人物，还看今朝！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/krolliaa"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">消息中间件是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么要使用消息中间件呢？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">消息中间件的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">RabbitMQ高性能的原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E2%80%94-AMQP%E5%8D%8F%E8%AE%AE"><span class="toc-text">RabbitMQ的底层原理 — AMQP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E5%BF%83%E8%84%8F"><span class="toc-text">RabbitMQ的心脏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Direct-Exchange%E3%80%90%E7%9B%B4%E8%BF%9E%E6%A8%A1%E5%BC%8F%E3%80%91"><span class="toc-text">Direct Exchange【直连模式】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fanout-Exchange%E3%80%90%E6%89%87%E5%BD%A2%E6%A8%A1%E5%BC%8F%E3%80%91"><span class="toc-text">Fanout Exchange【扇形模式】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Topic-Exchange%E3%80%90%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%E3%80%91"><span class="toc-text">Topic Exchange【主题模式】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-1"><span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85"><span class="toc-text">RabbitMQ快速安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-2"><span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">RabbitMQ命令行工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%85%B3%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">RabbitMQ消息交换的关键是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-3"><span class="toc-text">作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-MessageQueue"><span class="toc-text">14. MessageQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-text">14.1 同步通讯和异步通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">14.2 消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E4%BD%BF%E7%94%A8Docker%E5%AE%89%E8%A3%85RabbitMQ"><span class="toc-text">14.3 使用Docker安装RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-RabbitMQ%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">14.4 RabbitMQ中的角色及其基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-RabbitMQ%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AAMQP%E5%8D%8F%E8%AE%AE"><span class="toc-text">14.5 RabbitMQ的底层实现原理：AMQP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-RabbitMQ%E5%AE%98%E6%96%B9%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">14.6 RabbitMQ官方模型介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-RabbitMQ%E5%AE%98%E6%96%B9API%E5%AE%9E%E7%8E%B0HelloWorld%E6%A8%A1%E5%9E%8B"><span class="toc-text">14.7 RabbitMQ官方API实现HelloWorld模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-8-SpringAMQP%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B"><span class="toc-text">14.8 SpringAMQP实现发布订阅模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-1-Hello-World"><span class="toc-text">14.8.1 Hello-World</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-2-Work-Queue"><span class="toc-text">14.8.2 Work-Queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-3-Fanout"><span class="toc-text">14.8.3 Fanout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-4-Direct"><span class="toc-text">14.8.4 Direct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-5-Topic"><span class="toc-text">14.8.5 Topic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-9-%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-text">14.9 消息转换器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-text">20. 服务异步通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-%E4%BC%A0%E7%BB%9FMQ%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">20.1 传统MQ的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">20.2 消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#20-2-1-MQ%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%91%E9%80%81%E8%B7%AF%E4%B8%8A%E7%9A%84%E4%B8%A2%E5%A4%B1"><span class="toc-text">20.2.1 MQ如何解决发送路上的丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-2-2-MQ%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3MQ%E5%AE%95%E6%9C%BA%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="toc-text">20.2.2 MQ如何解决MQ宕机导致数据丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-2-3-MQ%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%95%E6%9C%BA%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="toc-text">20.2.3 MQ如何解决消费者宕机导致数据丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#20-2-3-1-%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%E6%9C%BA%E5%88%B6%E4%B9%8Bnone%E6%A8%A1%E5%BC%8F"><span class="toc-text">20.2.3.1 阅后即焚机制之none模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-2-3-2-%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%E6%9C%BA%E5%88%B6%E4%B9%8Bauto%E6%A8%A1%E5%BC%8F"><span class="toc-text">20.2.3.2 阅后即焚机制之auto模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-2-3-3-%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-text">20.2.3.3 消费失败重传机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-2-4-%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%80%BB%E7%BB%93"><span class="toc-text">20.2.4 消息可靠性总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%92%8C%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">20.3 死信队列和延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">20.3.1 什么是死信队列？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-2-%E5%88%A9%E7%94%A8%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8E%A5%E6%94%B6%E6%AD%BB%E4%BF%A1"><span class="toc-text">20.3.2 利用死信交换机接收死信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-3-%E5%B0%8F%E7%BB%93"><span class="toc-text">20.3.3 小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-4-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4TTL"><span class="toc-text">20.3.4 过期时间TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#20-3-4-1-%E6%8C%87%E5%AE%9A%E9%98%9F%E5%88%97%E7%9A%84TTL"><span class="toc-text">20.3.4.1 指定队列的TTL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-3-4-2-%E6%8C%87%E5%AE%9A%E6%B6%88%E6%81%AF%E7%9A%84TTL"><span class="toc-text">20.3.4.2 指定消息的TTL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-3-4-3-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">20.3.4.3 过期时间</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-5-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">20.3.5 延迟队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-6-%E5%AE%89%E8%A3%85DelayExchange%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%95%88%E6%9E%9C"><span class="toc-text">20.3.6 安装DelayExchange插件实现延迟队列效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-7-DelayExchange%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">20.3.7 DelayExchange的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-8-%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C"><span class="toc-text">20.3.8 延迟发送消息的具体操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-9-%E6%80%BB%E7%BB%93"><span class="toc-text">20.3.9 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98%E7%9A%84%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-text">20.5 解决消息堆积问题的惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#20-5-1-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-text">20.5.1 使用命令方式设置惰性队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-5-2-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-text">20.5.2 基于注解方式设置惰性队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-5-3-%E5%9F%BA%E4%BA%8EBean%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-text">20.5.3 基于Bean方式设置惰性队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-5-4-%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93"><span class="toc-text">20.5.4 惰性队列总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-MQ%E9%9B%86%E7%BE%A4"><span class="toc-text">20.6 MQ集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#20-6-1-%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="toc-text">20.6.1 普通集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-6-2-%E5%AE%89%E8%A3%85%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="toc-text">20.6.2 安装普通集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-6-3-%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="toc-text">20.6.3 镜像集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-6-4-%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="toc-text">20.6.4 安装镜像集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-6-5-%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-text">20.6.5 仲裁队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-6-6-%E6%B7%BB%E5%8A%A0%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-text">20.6.6 添加仲裁队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-6-7-%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9"><span class="toc-text">20.6.7 集群扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-6-8-%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97%E5%89%AF%E6%9C%AC%E6%89%A9%E5%AE%B9"><span class="toc-text">20.6.8 仲裁队列副本扩容</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/10/CollectionAndMap/" title="Java Collection And Map"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java Collection And Map"/></a><div class="content"><a class="title" href="/2022/10/10/CollectionAndMap/" title="Java Collection And Map">Java Collection And Map</a><time datetime="2022-10-10T09:21:32.789Z" title="发表于 2022-10-10 17:21:32">2022-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/03/%E7%89%9B%E5%AE%A2Java%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" title="牛客Java刷题记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="牛客Java刷题记录"/></a><div class="content"><a class="title" href="/2022/10/03/%E7%89%9B%E5%AE%A2Java%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" title="牛客Java刷题记录">牛客Java刷题记录</a><time datetime="2022-10-03T02:03:41.265Z" title="发表于 2022-10-03 10:03:41">2022-10-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/17/EasyExcel/" title="EasyExcel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/index_img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EasyExcel"/></a><div class="content"><a class="title" href="/2022/09/17/EasyExcel/" title="EasyExcel">EasyExcel</a><time datetime="2022-09-17T07:22:22.992Z" title="发表于 2022-09-17 15:22:22">2022-09-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/index_img/3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;1984 - 2022 By Krolliaa</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div></div></body></html>